## monorepo

`Monorepo` 是一种软件开发的策略模式，它代表"单一代码仓库"（Monolithic Repository）。在 `Monorepo` 模式中，所有相关的项目和组件都被存储在一个统一的代码仓库中，而不是分散在多个独立的代码仓库中。

```js
├── packages
|   ├── pkg1
|   |   ├── package.json
|   ├── pkg2
|   |   ├── package.json
├── package.json
├── lerna.json
```

### 演进

- 阶段一：单仓库巨石应用，一个 Git 仓库维护着项目代码，随着迭代业务复杂度的提升，项目代码会变得越来越多，越来越复杂，大量代码构建效率也会降低，最终导致了单体巨石应用，这种代码管理方式称之为 *`Monolith`*。
- 阶段二：多仓库多模块应用，于是将项目折解成多个业务模块，并在多 Git 仓库管理，模块解翘，降低了巨石应用的复杂度，每模块都可以独立编码、测试、发版，代码管理变得简化，构建效率也得以提升，这种代码管理方式称之为 *`Multirepo`*。
- 阶段三：单仓库多模块应用，随着业务复杂度的提升，模块仓库越来越多，MultiRepo 这种方式虽然从业务上解韬了，但增加了项目工程管理的难度，随着模块仓库达到一定数量级，会有几个问题:跨仓库代码难共享，分散在单仓库的模块依赖管理复杂(底层模块升级后，其他上层依赖需要及时更新，否则有问题)，增加了构建耗时。于是将多个项目集成到一个仓库下，共享工程配置，同时又快捷地共享模块代码，成为趋势，这种代码管理方式称之为 *`MonoRepo`*。

### 使用场景

中大型项目、多模块项目

*总的来说，如果我们在开发过程中，需要**跨组合作**，或是希望有几个有**互相引用关系**的项目，能协同开发，但又希望保证每个项目的**独立性**，那就值得尝试 Monorepo。*

*但是如果没有良好的复用机制、完善的流程、规范和完备的单元测试则不建议使用，意义不大。



## [pnpm](https://pnpm.io/zh/filtering#--filter-package_name)

### 优势

- **安装速度最快**（非扁平的包结构，没有`yarn/npm`的复杂的扁平算法，且只更新变化的文件）

- **节省磁盘空间** （统一安装包到磁盘的某个位置，项目中的`node_modules`通过`hard-link`的方式链接到实际的安装地址）

### 依赖包目录

#### 扁平结构

> 安装一个包，那么这个包依赖的包将一起被安装到与这个包同级的目录下。比如安装一个`express`包，打开目录下的`node_modules`会发现除了`express`之外，多出很多其他的包。
>
> 目前，使用`npm/yarn`安装包是扁平结构（以前是嵌套结构，**npm3**之后改为扁平结构）

扁平结构的问题：

- 依赖结构的不确定性（不同包依赖某个包的不同版本 最终安装的版本具有不确定性）
- 扁平化算法复杂，耗时
- 非法访问未声明的包
- 幽灵依赖：存在依赖提升，某个依赖使用的依赖，并没有在项目的`package.json`中声明，也可以直接使用

#### 嵌套结构：

> 一个包的依赖包会安装在这个包文件下的`node_modules`下，而依赖的依赖会安装到依赖包文件的`node_modules`下。

嵌套结构的问题：

- **包文件的目录可能会非常长**
- **重复安装包**
- **相同包的实例不能共享**

#### pnpm

> 只安装对应的包，且这个被软链到了其他的地方

- .modlues.yaml 包含了一些`pnpm`包管理的配置信息
- .pnpm 下有需要安装的所有依赖包

![img](/notes/imgs/vue/pnpm.jpeg)

- 当我们安装`bar`包时，根目录下只包含安装的包`bar`
- 而`node_modules`目录下的`bar`包会`软链接`到`.pnpm/bar/node_modules/bar@*.*.*`
- bar的依赖包foo会被提升到.pnpm的根目录下，其他包依赖foo时也会`软链接`到这里
- 而bar和foo实际通过`硬链接`到`.pnpm store`中

### 命令

#### 安装包

```shell
pnpm add <pkg>
# 保存到 dependencies 配置项下
pnpm add <pkg> sax
# 保存到 devDependencies 配置项下
pnpm add <pkg> -D
# 安装到全局环境
pnpm add <pkg> -g
# 安装指定版本
pnpm add <pkg>@3.0.0
# 安装所有依赖
pnpm install
pnpm i
```

#### 卸载包

```shell
pnpm remove <pkg>
pnpm rm
pnpm uninstall
pnpm un
```

#### 运行脚本

```shell
pnpm run #script
```

### workspace

将多个项目合并到一个仓库中

创建`pnpm-workspace.yaml`



## 组件库搭建

### 目录

![image-20231017170906586](/notes/imgs/vue/组件库目录.png)

组件搭建用到了`pnpm monorepo`

- `example`中存放组件使用示例

- `packages`中存放组件

  - `components`是组件的代码
  - `utils`是用到的公共方法
  - `theme-chalk`是样式的配置

- `pnpm-workspace.yaml`是`monorepo`配置文件

  ```yam
  packages:
    - 'packages/**' #存放编写的组件
    - example
  ```

- 包名称配置

  - 最外层`package.json`中，`name`为`yh-components`
  - `example`和`packages`下的每个文件夹都有一个`package.json`，`name`为`@yh-components/xxx`

- 互相引用

  文件夹之间想要互相引用，在根目录下将文件夹软链接过去

  ```shell
  # -w可以将依赖包安装到工程的根目录下，作为所有包的公共依赖
  pnpm install @yh-components/components -w
  ```

  ![image-20231017171614481](/notes/imgs/vue/组件库软链接.png)

- pnpm在最外层执行内部某个文件夹的命令

  ```json
  // example
  "scripts": {
  	"dev": "vite"
  },
  
  // 根目录
  "scripts": {
  	"dev:example": "pnpm -C example dev"
  },
  ```

### 组件导出

- 如果要支持按需引入，每个组件需要单独导出

  - 单个组件

    ```js
    import Button from './Index.vue';
    import { withInstall } from '@yh-components/utils/withInstall';
    
    const YHButton = withInstall(Button);
    
    /*
    import type { App, Plugin } from 'vue';
    
    type SFCWithInstall<T> = T & Plugin;
    
    export const withInstall = <T>(com: T) => {
        (com as SFCWithInstall<T>).install = (app: App) => {
            app.component((com as any).name, (com as any));
        };
        return com as SFCWithInstall<T>;
    }
    */
    
    export default YHButton;
    ```
