# 数据存储 #
需求：  
1. 已登录状态，复制域名在同一浏览器访问不强制重新登录；  
1. 同一浏览器可以多用户登录；  
1. 已登录状态，复制域名在不同浏览器访问强制重新登录；  
目前遇到的问题  
使用cookie：同一浏览器不能同时登陆两个账号（思路：setCookie时判断）  
使用session：同一浏览器也需要重新登录
## Cookie ##
**js设置cookie时，最好使用encodeURIComponent()对key和value进行编码，其他参数比如expires、path等不需要进行编码**

### document.cookie ###

读：所有的key-value

写：在原有cookie后添加（只需要documnt.cookie="新增cookie=value"）

删除：将key值对应的value清空

### CookieUtil对象 ###

**自定义CookieUtil对象**

    var CookieUtil = {
        // 设置cookie
        set : function (name, value, expires, domain, path, secure) {
            var cookieText = "";
            cookieText += encodeURIComponent(name) + "=" + encodeURIComponent(value);
            if (expires instanceof Date) {
                cookieText += "; expires=" + expires.toGMTString();
            }
            if (path) {
                cookieText += "; path=" + path;
            }
            if (domain) {
                cookieText += "; domain=" + domain;
            }
            if (secure) {
                cookieText += "; secure";
            }
            document.cookie = cookieText;
        },
        // name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure
        // 获取cookie
        get : function (name) {
            var cookieName = encodeURIComponent(name) + "=",
                cookieStart = document.cookie.indexOf(cookieName),
                cookieValue = "";
            if (cookieStart > -1) {
                var cookieEnd = document.cookie.indexOf (";", cookieStart);
                if (cookieEnd == -1) {
                    cookieEnd = document.cookie.length;
                }
                cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));
            }
            return cookieValue; 
        },
        // 删除cookie
        unset : function (name, domain, path, secure) {
            this.set(name, "", Date(0), domain, path, secure);
        }
    };

### 子cookie ###
**为了绕开浏览器单域名下的cookie数限制**

表现形式：key=key1=value1&key2=value2&key3=value3  

**自定义SubCookieUtil对象**  

    var SubCookieUtil = {

        get: function (name, subName) {
            var subCookies = this.getAll(name);
            if (subCookies) {
                return subCookies[subName];
            } else {
                return null;
            }
        },

        getAll: function (name) {
            var cookieName = encodeURIComponent(name) + "=",
                cookieStart = document.cookie.indexOf(cookieName),
                cookieValue = null,
                result = {};

            if (cookieStart > -1) {
                var cookieEnd = document.cookie.indexOf(";", cookieStart);
                if (cookieEnd == -1) {
                    cookieEnd = document.cookie.length;
                }
                cookieValue = document.cookie.substring(cookieStart + cookieName.length, cookieEnd);

                if (cookieValue.length > 0) {
                    var subCookies = cookieValue.split("&");

                    for (var i = 0, len = subCookies.length; i < len; i++) {
                        var parts = subCookies[i].split("=");
                        result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
                    }
                    return result;
                }
            }
            return null;
        },

        set: function (name, subName, value, expires, path, domain, secure) {
            var subcookies = this.getAll(name) || {};
            subcookies[subName] = value;
            this.setAll(name, subcookies, expires, path, domain, secure);
        },

        setAll: function (name, subcookies, expires, path, domain, secure) {
	
            var cookieText = encodeURIComponent(name) + "=";
            var subcookieParts = new Array();

            for (var subName in subcookies) {
                if (subName.length > 0 && subcookies.hasOwnProperty(subName)) {
                    subcookieParts.push(encodeURIComponent(subName) + "=" + encodeURIComponent(subcookies[subName]));
                }
            }

            if (subcookieParts.length > 0) {
                cookieText += subcookieParts.join("&");

                if (expires instanceof Date) {
                    cookieText += "; expires=" + expires.toGMTString();
                }

                if (path) {
                    cookieText += "; path=" + path;
                }

                if (domain) {
                    cookieText += ";domain=" + domain;
                }

                if (secure) {
                    cookieText += ";secure";
                }
            } else {
                cookieText += "; expires=" + (new Date(0)).toGMTString();
            }
            document.cookie = cookieText;
        },

        unset: function (name, subName, path, domain, secure) {
            var subcookies = this.getAll(name);
            if (subcookies) {
                delete subcookies[subName];
                this.setAll(name, subcookies, null, path, domain, secure);
            }
        },

        unsetAll: function (name, path, domain, secure) {
            this.setAll(name, null, new Date(0), path, domain, secure);
        }
    };
	//假设document.cookie=data=name=Nicholas&book=Professional%20JavaScript

	//取得全部子cookie
	var data = SubCookieUtil.getAll("data");
	alert(data.name); //"Nicholas"
	alert(data.book); //"Professional JavaScript"

	//逐个取得子cookie
	alert(SubCookieUtil.get("data", "name")); //"Nicholas"
	alert(SubCookieUtil.get("data", "book")); //"Professional JavaScript"

	//设置两个cookie
	SubCookieUtil.set("data", "name", "Nicholas");
	SubCookieUtil.set("data", "book", "Professional JavaScript");
	
	//设置全部子cookie和失效日期
	SubCookieUtil.setAll("data", { name: "Nicholas", book: "Professional Javascript" }, new Data("January 1, 2010"));
	
	//修改名字的值，并修改cookie的失效日期
	SubCookieUtil.set("data", "name", "Michael", new Date("February 1, 2010"));

## Web存储机制 ##
### Storage类型 ###
- clear()：删除所有值，不兼容FF
- getItem(name)：获取name对应的value
- setItem(name,value)：设置session
- removeItem(name)：删除name-value
- key(index)：获取index位置处的name
### sessionStorage对象 ###
存储于某个会话，也就是该数据值保持到浏览器关闭，可以跨越页面刷新而存在。

**兼容IE8处理**
FF和chrome实现了同步写入；IE为异步写入，会相对较慢（大量数据）。  
在IE8中可强制把数据写入磁盘：在设置新数据之前使用begin()方法，并且在所有设置完成之后调用commit()方法。

	//只适用于IE8
	sessionStorage.begin();
	sessionStorage.name="Nicholas";
	sessionStorage.book="Professional JavaScript";
	sessionStorage.commit();
### globalStorage ###
