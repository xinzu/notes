<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>yh的学习文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/notes/assets/css/0.styles.aa6162e3.css" as="style"><link rel="preload" href="/notes/assets/js/app.1087d36c.js" as="script"><link rel="preload" href="/notes/assets/js/2.c60e90e7.js" as="script"><link rel="preload" href="/notes/assets/js/15.cfd3f1d4.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.01fa8667.js"><link rel="prefetch" href="/notes/assets/js/11.c88f7c00.js"><link rel="prefetch" href="/notes/assets/js/12.6db8237b.js"><link rel="prefetch" href="/notes/assets/js/13.b0676ec3.js"><link rel="prefetch" href="/notes/assets/js/14.e0842cc7.js"><link rel="prefetch" href="/notes/assets/js/16.5d640bd3.js"><link rel="prefetch" href="/notes/assets/js/17.ef9feeb2.js"><link rel="prefetch" href="/notes/assets/js/18.9c483fc6.js"><link rel="prefetch" href="/notes/assets/js/19.7195c25f.js"><link rel="prefetch" href="/notes/assets/js/20.8bd4ae2f.js"><link rel="prefetch" href="/notes/assets/js/21.86a01db9.js"><link rel="prefetch" href="/notes/assets/js/22.c55be918.js"><link rel="prefetch" href="/notes/assets/js/23.c7b19a03.js"><link rel="prefetch" href="/notes/assets/js/24.81bbff94.js"><link rel="prefetch" href="/notes/assets/js/25.34ef620c.js"><link rel="prefetch" href="/notes/assets/js/26.d6f02773.js"><link rel="prefetch" href="/notes/assets/js/27.1101284c.js"><link rel="prefetch" href="/notes/assets/js/28.97080c1e.js"><link rel="prefetch" href="/notes/assets/js/29.79abbb45.js"><link rel="prefetch" href="/notes/assets/js/3.0cf10e4b.js"><link rel="prefetch" href="/notes/assets/js/30.21217f75.js"><link rel="prefetch" href="/notes/assets/js/31.dea3ce52.js"><link rel="prefetch" href="/notes/assets/js/32.ce5e5d1a.js"><link rel="prefetch" href="/notes/assets/js/33.1b96854a.js"><link rel="prefetch" href="/notes/assets/js/4.b7d0708f.js"><link rel="prefetch" href="/notes/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/notes/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/notes/assets/js/7.03139e79.js"><link rel="prefetch" href="/notes/assets/js/8.547b5cb4.js"><link rel="prefetch" href="/notes/assets/js/9.1de6ed85.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.aa6162e3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">yh的学习文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础知识扩展</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/基础知识扩展/对象.html" class="sidebar-link">对象</a></li><li><a href="/notes/基础知识扩展/对象迭代的方法.html" class="sidebar-link">对象迭代的方法</a></li><li><a href="/notes/基础知识扩展/正则.html" class="sidebar-link">正则</a></li><li><a href="/notes/基础知识扩展/存储机制.html" class="sidebar-link">存储机制</a></li><li><a href="/notes/基础知识扩展/禁用弹出框后退页面.html" class="sidebar-link">禁用弹出框后退页面</a></li><li><a href="/notes/基础知识扩展/强制360浏览采用哪种内核.html" class="sidebar-link">强制360浏览采用哪种内核</a></li><li><a href="/notes/基础知识扩展/setTimeout.html" class="sidebar-link">setTimeout</a></li><li><a href="/notes/基础知识扩展/单行代码.html" class="sidebar-link">数组-单行代码</a></li><li><a href="/notes/基础知识扩展/宏任务和微任务.html" class="sidebar-link">宏任务和微任务</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>http</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/notes/typescript/ts.html" class="sidebar-link">typescript</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具类</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>开发中遇到的问题</p> <p>// TODO</p> <p><strong>https://www.lilichao.com/</strong></p> <h2 id="一些问题"><a href="#一些问题" class="header-anchor">#</a> <strong>一些问题</strong></h2> <h3 id="为什么要在componentdidmount中获取数据"><a href="#为什么要在componentdidmount中获取数据" class="header-anchor">#</a> 为什么要在<code>componentDidMount</code>中获取数据？</h3> <h3 id="componentdidupdate可以做什么"><a href="#componentdidupdate可以做什么" class="header-anchor">#</a> <code>componentDidUpdate</code>可以做什么？</h3> <h3 id="你真的理解setstate吗"><a href="#你真的理解setstate吗" class="header-anchor">#</a> 你真的理解<code>setState</code>吗？</h3> <p>setState放在异步函数中，如果用setState(count+1)这种形式，触发多次只会执行一次；要改为setState(count =&gt; count + 1)</p> <h3 id="setstate什么时候是异步-同步的"><a href="#setstate什么时候是异步-同步的" class="header-anchor">#</a> <code>setState</code>什么时候是异步/同步的？</h3> <p><img src="/notes/imgs/react/image-20230201103604483.png" alt="image-20230201103604483"></p> <ul><li><p><strong>react18</strong></p> <p>setState 和 useState的区别</p> <ul><li><p>相同点：执行多个set（相同/不同都可以）时只执行一次render；同步和异步render执行次数和结果都是一样的</p></li> <li><p>不同点：setState只执行最后一次，useState每次都会执行（比如同一个state.a=0执行两次++，setState最后返回的是1，useState返回的是2）</p></li></ul></li> <li><p><strong>react18之前</strong></p> <p>在异步函数中是同步的，在同步函数中是异步的</p></li></ul> <h2 id="多页面配置"><a href="#多页面配置" class="header-anchor">#</a> 多页面配置</h2> <p><strong>修改配置之后要重新运行yarn start</strong></p> <ol><li><p>修改/config/paths.js</p> <div class="language- extra-class"><pre class="language-text"><code>// 在module.exports中添加
appLoginHtml: resolveApp(&quot;public/login.html&quot;),
appLoginJs: resolveModule(resolveApp, &quot;src/login&quot;),
</code></pre></div></li> <li><p>修改webpack.config.js配置文件</p> <div class="language- extra-class"><pre class="language-text"><code>// entry
entry: {
  index:
 isEnvDevelopment &amp;&amp; !shouldUseReactRefresh
      ? [webpackDevClientEntry, paths.appIndexJs]
      : paths.appIndexJs,
  login:
    isEnvDevelopment &amp;&amp; !shouldUseReactRefresh
      ? [webpackDevClientEntry, paths.appLoginJs]
      : paths.appLoginJs
},
/*
// 简单点
entry: {
  index: paths.appIndexJs,
  login: paths.appLoginJs
},
*/

// output
// 将filename修改为[name].js
filename: isEnvProduction
        ? &quot;static/js/[name].[contenthash:8].js&quot;
        : isEnvDevelopment &amp;&amp; &quot;static/js/[name].js&quot;,
        
// plugins
// HtmlWebpackPlugin  修改之前的，再新增一个
new HtmlWebpackPlugin(
    Object.assign(
      {},
      {
        inject: true,
        template: paths.appHtml,
        
        // 修改点： filename配置项和chunks
        filename: &quot;index.html&quot;,
        chunks: [&quot;index&quot;],
      },
      isEnvProduction
        ? {
            minify: {
              removeComments: true,
              collapseWhitespace: true,
              removeRedundantAttributes: true,
              useShortDoctype: true,
              removeEmptyAttributes: true,
              removeStyleLinkTypeAttributes: true,
              keepClosingSlash: true,
              minifyJS: true,
              minifyCSS: true,
              minifyURLs: true,
            },
          }
        : undefined
    )
  ),
  new HtmlWebpackPlugin(
    Object.assign(
      {},
      {
        inject: true,
        template: paths.appLoginHtml,
        filename: &quot;login.html&quot;,
        chunks: [&quot;login&quot;],
      },
      isEnvProduction
        ? {
            minify: {
              removeComments: true,
              collapseWhitespace: true,
              removeRedundantAttributes: true,
              useShortDoctype: true,
              removeEmptyAttributes: true,
              removeStyleLinkTypeAttributes: true,
              keepClosingSlash: true,
              minifyJS: true,
              minifyCSS: true,
              minifyURLs: true,
            },
          }
        : undefined
    )
  ),

// ManifestPlugin  entrypoints.main 修改为 entrypoints.index
new ManifestPlugin({
    fileName: &quot;asset-manifest.json&quot;,
    publicPath: paths.publicUrlOrPath,
    generate: (seed, files, entrypoints) =&gt; {
      const manifestFiles = files.reduce((manifest, file) =&gt; {
        manifest[file.name] = file.path;
        return manifest;
      }, seed);
      const entrypointFiles = entrypoints.index.filter(
        (fileName) =&gt; !fileName.endsWith(&quot;.map&quot;)
      );

      return {
        files: manifestFiles,
        entrypoints: entrypointFiles,
      };
    },
  }),
</code></pre></div></li></ol> <h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="jsx语法"><a href="#jsx语法" class="header-anchor">#</a> JSX语法</h3> <ol><li><p><code>React.createElement(component, props, ...children)</code> 函数的语法糖</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;MyButton color=&quot;blue&quot; shadowSize={2}&gt;
  Click Me
&lt;/MyButton&gt;

// 会被编译为
React.createElement(
  MyButton,
  {color: 'blue', shadowSize: 2},
  'Click Me'
)
</code></pre></div><ul><li><strong>如果没有子节点，可以使用自闭合的标签形式</strong></li></ul> <p><code>&lt;div className=&quot;sidebar&quot; /&gt;</code></p> <ul><li><strong>必须有结束标签</strong></li></ul></li> <li><p>大写字母开头的 JSX 标签意味着它们是 React 组件</p> <p><strong>用户自定义的组件必须以大写字母开头，否则React 会认为 它 是一个 HTML 标签（因为它没有以大写字母开头）</strong></p></li> <li><p>点语法</p> <blockquote><p>当你在一个模块中导出许多 React 组件时，以使用点语法来引用一个 React 组件。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react';

const MyComponents = {
  DatePicker: function DatePicker(props) {
    return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;;
  }
}

function BlueDatePicker() {
  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;
}
</code></pre></div></li> <li><p>动态组件</p> <div class="language- extra-class"><pre class="language-text"><code>function Story(props) {
  // 这里一定要先赋值再使用，JSX 类型不能是一个表达式
  const SpecificStory = components[props.storyType];
  return &lt;SpecificStory story={props.story} /&gt;;
}

// 错误使用
function Story(props) {
  return &lt;components[props.storyType] story={props.story} /&gt;;
}
</code></pre></div></li> <li><p>props默认值为true</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;MyTextBox autocomplete /&gt;
// 等价于
&lt;MyTextBox autocomplete={true} /&gt;
</code></pre></div></li> <li><p>JSX 会移除行首尾的空格以及空行。与标签相邻的空行均会被删除，文本字符串之间的新行会被压缩为一个空格。因此以下的几种方式都是等价的：</p> <div class="language- extra-class"><pre class="language-text"><code>// 1
&lt;div&gt;Hello World&lt;/div&gt;

// 2
&lt;div&gt;
  Hello World
&lt;/div&gt;

// 3
&lt;div&gt;
  Hello
  World
&lt;/div&gt;

// 4
&lt;div&gt;

  Hello World
&lt;/div&gt;
</code></pre></div></li> <li><p>布尔类型、Null、Undefined、Symbol、BigInt将会被忽略</p> <blockquote><p><code>false</code>, <code>null</code>, <code>undefined</code>, and <code>true</code> 是合法的子元素。但它们并不会被渲染。</p></blockquote> <p>以下的JSX表达式渲染结果相同</p> <div class="language- extra-class"><pre class="language-text"><code>// 1
&lt;div /&gt;

// 2
&lt;div&gt;&lt;/div&gt;

// 3
&lt;div&gt;{false}&lt;/div&gt;

// 4
&lt;div&gt;{null}&lt;/div&gt;

// 5
&lt;div&gt;{undefined}&lt;/div&gt;

// 6
&lt;div&gt;{true}&lt;/div&gt;
</code></pre></div></li> <li><p>数据是一个数组时，React可以拿到值进行展示，但如果是一个对象，只能拿到key值，无法进行展示</p> <p><img src="/notes/imgs/react/object%E6%97%A0%E6%B3%95%E4%BD%9C%E4%B8%BAchild.png" alt="image-20210322141300829"></p></li></ol> <h3 id="三大核心属性"><a href="#三大核心属性" class="header-anchor">#</a> 三大核心属性</h3> <p><strong>组件实例的属性</strong>，意味着<a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6">函数组件</a>没有这些属性</p> <h4 id="state"><a href="#state" class="header-anchor">#</a> state</h4> <ul><li><p>state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合）</p></li> <li><p>组件被称为状态机，通过更新组件的state来更新对应的页面显示（重新渲染组件）</p></li> <li><p>组件中render方法中的this为组件实例对象</p></li> <li><p>组件自定义的方法中this为undefined，如何解决？</p> <ul><li>a.强制绑定this:通过函数对象的bind()</li> <li>b.箭头函数</li></ul></li> <li><p>不能直接修改或更新状态数据，用setState</p></li></ul> <h4 id="props"><a href="#props" class="header-anchor">#</a> props</h4> <ul><li>每个组件对象都会有props属性</li> <li>组件标签的所有属性都保存在props中</li> <li>props的作用：通过标签属性从组件外向组件内传递变化的数据</li> <li>组件内部不要修改props数据</li> <li>给props加限制：prop-types库</li></ul> <h4 id="refs"><a href="#refs" class="header-anchor">#</a> refs</h4> <p><strong>获取元素的真实DOM对象。</strong></p> <blockquote><p>尽量减少在React中操作原生的DOM对象，如果实在非得操作也尽量是那些不会对数据产生影响的操作，像是设置焦点、读取信息等。</p></blockquote> <p>​	定义ref的三种方式</p> <ol><li><div class="language- extra-class"><pre class="language-text"><code>&lt;input ref='inputRef' /&gt;

this.refs.inputRef
</code></pre></div></li> <li><div class="language- extra-class"><pre class="language-text"><code>this.inputRef = React.createRef();
&lt;input ref={this.inputRef} /&gt;
</code></pre></div></li> <li><div class="language- extra-class"><pre class="language-text"><code>回调ref
&lt;input ref={ref=this.inputRef = ref} /&gt;
</code></pre></div></li></ol> <h4 id="与html的差异"><a href="#与html的差异" class="header-anchor">#</a> 与HTML的差异</h4> <ol><li>class——className</li> <li>style属性：CSS——JS对象</li></ol> <h3 id="生命周期-钩子函数"><a href="#生命周期-钩子函数" class="header-anchor">#</a> 生命周期（钩子函数）</h3> <p>https://zh-hans.reactjs.org/docs/react-component.html#</p> <div class="language- extra-class"><pre class="language-text"><code>constructor就可以拿到refs和定义的事件
</code></pre></div><h4 id="主要的钩子函数"><a href="#主要的钩子函数" class="header-anchor">#</a> 主要的钩子函数</h4> <ul><li>挂载：constructor、getDerivedStateFromProps、render、componentDidMount</li> <li>更新：getDerivedStateFromProps、shouldComponentUpdate、render、getSnapshotBeforeUpdate、componentDidUpdate</li> <li>卸载：componentDidUnmount</li> <li>错误处理：getDerivedStateFromError、componentDidCatch</li> <li>过时方法：UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps、UNSAFE_componentWillUpdate，在<strong>react17</strong>版本后会被弃用，<strong>但现在仍可以使用</strong></li></ul> <p>**副作用：**一个函数在执行过程中产生了外部可观察的变化。比如：修改全局变量，修改传参，console.log()等外部可观察它的变化。</p> <h5 id="常见方法"><a href="#常见方法" class="header-anchor">#</a> 常见方法</h5> <ul><li><code>constructor</code>：通过super来绑定组件身上的props，只在挂载时执行一次</li> <li><code>componentDidMount</code>：一般在这个函数中进行<strong>异步的</strong>数据获取</li> <li><code>render</code>：渲染页面，挂载、更新时都会触发</li> <li><code>shouldComponentUpdate</code>：是否进行更新，如果返回false，则不会触发render</li> <li><code>componentDidUpdate</code>：组件开始重新渲染之前调用(TODO: 这个钩子可以做什么？)</li> <li><code>componentDidUnmount</code>：组件卸载时触发，一般用来重置数据、清除定时器、移除监听</li></ul> <h5 id="错误边界-error-boundaries"><a href="#错误边界-error-boundaries" class="header-anchor">#</a> 错误边界（Error Boundaries）</h5> <p>在子组件树种的任何位置捕获JS错误，<strong>它无法捕获其自身的错误</strong></p> <p><strong>只有class组件才可以成为错误边界组件</strong></p> <ul><li><code>getDerivedStateFromError</code>：从错误中获取 <code>state</code>，渲染备用 UI （在render中自定义降级后的备用UI）</li> <li><code>componentDidCatch</code>：捕获错误并进行处理，比如打印错误、上报服务器</li></ul> <h5 id="react16新增"><a href="#react16新增" class="header-anchor">#</a> react16新增</h5> <ul><li><p><code>getDerivedStateFromProps</code>：在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 <code>null</code> 则不更新任何内容。此方法适用于罕见的用例，即 <strong>state 的值在任何时候都取决于 props</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>开发中遇到的实例：从不同页面进到同一个页面进行数据初始化的时候，state的值取决于props
</code></pre></div></li> <li><p><code>getSnapshotBeforeUpdate</code>：在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>class ScrollingList extends React.Component {
  constructor(props) {
    super(props);
    this.listRef = React.createRef();
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 我们是否在 list 中添加新的 items ？
    // 捕获滚动位置以便我们稍后调整滚动位置。
    if (prevProps.list.length &lt; this.props.list.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，
    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。
    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）
    if (snapshot !== null) {
      const list = this.listRef.current;
      list.scrollTop = list.scrollHeight - snapshot;
    }
  }

  render() {
    return (
      &lt;div ref={this.listRef}&gt;{/* ...contents... */}&lt;/div&gt;
    );
  }
}
</code></pre></div></li></ul> <h5 id="废弃方法"><a href="#废弃方法" class="header-anchor">#</a> 废弃方法</h5> <p>在React17之前，这些方法仍然有效，这几个生命周期之前的函数名没有UNSAFE_前缀。</p> <ul><li><code>UNSAFE_componentWillMount</code>：在挂载之前被调用。它在 <code>render()</code> 之前调用，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。通常，我们建议使用 <code>constructor()</code> 来初始化 state。<strong>此方法是服务端渲染唯一会调用的生命周期函数。</strong></li> <li><code>UNSAFE_componentWillReceiveProps</code>：<code>getDerivedStateFromProps</code></li> <li><code>UNSAFE_componentWillUpdate</code>：当组件收到新的 props 或 state 时，会在渲染之前调用，初始渲染不会调用此方法。
<ul><li>此方法中不能调用 <code>this.setState()</code>；</li> <li>返回之前，也不应该执行任何其他操作触发对 React 组件的更新</li></ul></li></ul> <h4 id="钩子函数调用顺序"><a href="#钩子函数调用顺序" class="header-anchor">#</a> <strong>钩子函数调用顺序</strong></h4> <p><img src="/notes/imgs/react/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react生命周期"></p> <h4 id="手动调用"><a href="#手动调用" class="header-anchor">#</a> 手动调用</h4> <p>上述的钩子函数是React机制主动调用的方法，还有两种方法可以触发钩子函数：<code>setState</code>和<code>forceUpdate</code></p> <p>调用 <code>forceUpdate 将致使组件调用</code>render方法，此操作会跳过该组件的 <code>shouldComponentUpdate。但其子组件会触发正常的生命周期方法，包括</code>shouldComponentUpdate` 方法。如果标记发生变化，React 仍将只更新 DOM。</p> <p>// TODO</p> <h4 id="原理解析"><a href="#原理解析" class="header-anchor">#</a> 原理解析</h4> <h3 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h3> <blockquote><p>定义组件有两个要求</p> <ol><li>组件名称必须以大写字母开头</li> <li>组件返回值只能有<strong>一个</strong>根元素</li></ol></blockquote> <p><strong>props默认值</strong></p> <div class="language- extra-class"><pre class="language-text"><code>{
	history: {}, // 就是history对象
	location: {},
	match: {
		param: {
			title: &quot;abc&quot;
		}
		path: &quot;/page/:title&quot;
		url: &quot;/page/abc&quot;
	}
}
</code></pre></div><h4 id="类组件"><a href="#类组件" class="header-anchor">#</a> 类组件</h4> <p>可以定义生命周期钩子函数，render是其中必须要实现的方法</p> <div class="language- extra-class"><pre class="language-text"><code>class Welcome extends React.Component {
  render() {
    return (
      &lt;h1&gt;Welcome { this.props.name }&lt;/h1&gt;
    );
  }
}
ReactDOM.render(&lt;Welcome name='react' /&gt;, document.getElementById('root'));
</code></pre></div><h4 id="函数组件"><a href="#函数组件" class="header-anchor">#</a> 函数组件</h4> <p>函数组件接收一个单一的 <code>props</code> 对象并返回了一个React元素</p> <div class="language- extra-class"><pre class="language-text"><code>function Welcome (props) {
  return &lt;h1&gt;Welcome {props.name}&lt;/h1&gt;
}
ReactDOM.render(&lt;Welcome name='react' /&gt;, document.getElementById('root'));

</code></pre></div><p><strong>区别</strong></p> <ol><li>函数组件的性能比类组件的性能要高。因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</li> <li>函数组件写法比较简单，没有this、state、生命周期（因为函数式组件没有继承React.Component，由于生命周期函数是React.Component类的方法实现的，所以没继承这个类，自然就没法使用生命周期函数了）。对于不需要state和生命周期函数调用的组件可使用函数组件。</li> <li>函数组件没有生命周期、state的问题可以通过React Hook解决</li></ol> <h5 id="相关知识点-严格模式下this的指向问题"><a href="#相关知识点-严格模式下this的指向问题" class="header-anchor">#</a> 相关知识点--严格模式下this的指向问题</h5> <ol><li>非严格模式下默认指向window</li> <li>严格模式下传null指向null，不传或者传undefined都指向undefined。在函数组件中，this==undefined</li></ol> <h4 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h4> <h5 id="父子"><a href="#父子" class="header-anchor">#</a> 父子</h5> <ul><li><p>父-&gt;子：props</p> <p><img src="/notes/imgs/react/%E7%88%B6%E4%BC%A0%E5%AD%90.jpg" alt="父传子"></p></li> <li><p>子-&gt;父：父组件将一个函数作为props传给子组件，子组件通过this.props.xxx(args)传值，与vue中的$emit类似</p> <p><img src="/notes/imgs/react/%E5%AD%90%E4%BC%A0%E7%88%B6.jpg" alt="子传父"></p></li></ul> <h5 id="兄弟"><a href="#兄弟" class="header-anchor">#</a> 兄弟</h5> <p>兄弟组件之间的传值，是通过父组件做的中转 ，流程为：<strong>组件A</strong> -- <code>传值</code> --&gt; <strong>父组件</strong> -- <code>传值</code> --&gt; <strong>组件B</strong></p> <p><img src="/notes/imgs/react/%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.jpg" alt="兄弟组件传值"></p> <h5 id="跨级"><a href="#跨级" class="header-anchor">#</a> 跨级</h5> <h6 id="props层层传递"><a href="#props层层传递" class="header-anchor">#</a> <strong>props层层传递</strong></h6> <p>组件嵌套过深时，不建议使用这种方式</p> <h6 id="redux"><a href="#redux" class="header-anchor">#</a> <strong><a href="#Redux">redux</a></strong></h6> <h6 id="context对象"><a href="#context对象" class="header-anchor">#</a> context对象</h6> <p>https://react.docschina.org/docs/context.html#reactcreatecontext</p> <p><strong>React context的局限性</strong></p> <ol><li>在组件树中，如果中间某一个组件 ShouldComponentUpdate中 return false ，会阻碍 context 的正常传值，导致子组件无法获取更新。</li> <li>组件本身 extends React.PureComponent 也会阻碍 context 的更新。</li></ol> <blockquote><p>​	PureComponent会对<code>props</code>和<code>state</code>进行浅比较，跳过不必要的更新，提高组件性能。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// context在如下的生命周期钩子中可以使用
constructor(props, context)
componentWillReceiveProps(nextProps, nextContext)
shouldComponentUpdate(nextProps, nextState, nextContext)
componentWillUpdate(nextProps, nextState, nextContext)
componentDidUpdate(prevProps, prevState, prevContext)
</code></pre></div><ul><li><p>老版本的context</p> <ul><li>getChildContext 根组件中声明，一个函数，返回一个对象，就是context</li> <li>childContextTypes 根组件中声明，指定context的结构类型，如不指定，会产生错误</li> <li>contextTypes 子孙组件中声明，指定要接收的context的结构类型，可以只是context的一部分结构。contextTypes 没有定义，context将是一个空对象。</li> <li>this.context 在子孙组件中通过此来获取上下文</li></ul></li> <li><p>新版本的context</p> <p>新版本的React context使用了Provider和Customer模式，和react-redux的模式非常像。</p> <ul><li>在顶层的Provider中传入value，</li> <li>在子孙级的Consumer中获取该值，并且能够传递函数，用来修改context</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//创建Context组件
const ThemeContext = React.createContext({
  theme: 'dark',
  toggle: () =&gt; {}, //向上下文设定一个回调方法
});

//运行APP
class App extends React.Component {
  constructor(props) {
    super(props);

    this.toggle = () =&gt; { //设定toggle方法，会作为context参数传递
      this.setState(state =&gt; ({
        theme:
          state.theme === themes.dark
            ? themes.light
            : themes.dark,
      }));
    };

    this.state = {
      theme: themes.light,
      toggle: this.toggle,
    };
  }

  render() {
    return (
      &lt;ThemeContext.Provider value={this.state}&gt; //state包含了toggle方法
        &lt;Content /&gt;
      &lt;/ThemeContext.Provider&gt;
    );
  }
}

//中间组件
function Content() {
  return (
    &lt;div&gt;
      &lt;Button /&gt;
    &lt;/div&gt;
  );
}

//接收组件
function Button() {
  return (
    &lt;ThemeContext.Consumer&gt;
      {({theme, toggle}) =&gt; (
        &lt;button
          onClick={toggle} //调用回调
          style={{backgroundColor: theme}}&gt;
          Toggle Theme
        &lt;/button&gt;
      )}
    &lt;/ThemeContext.Consumer&gt;
  );
}
</code></pre></div></li></ul> <h6 id="pubsub"><a href="#pubsub" class="header-anchor">#</a> <strong>Pubsub</strong></h6> <div class="language- extra-class"><pre class="language-text"><code>// A.js  父组件
import React, { Component } from &quot;react&quot;;
import PubSub from &quot;pubsub-js&quot;;
import B from &quot;./B&quot;;

export default class A extends Component {
  constructor(props) {
    super(props);
    this.state = {
      message: &quot;none&quot;,
    };
  }
  componentDidMount() {
    this.pubsub_token = PubSub.subscribe(
      &quot;PubSubmessage&quot;,
      function (topic, message) {
        console.log(&quot;topic&quot;, topic);
        this.setState({
          message,
        });
      }.bind(this)
    );
  }
  componentWillUnmount() {
    PubSub.unsubscribe(this.pubsub_token);
  }
  render() {
    return (
      &lt;div&gt;
        &lt;B&gt;&lt;/B&gt;
        &lt;div style={{ marginTop: &quot;1.5em&quot; }}&gt;{this.props.children}&lt;/div&gt;
        &lt;div style={{ marginTop: &quot;1.5em&quot; }}&gt;
          page A message:{this.state.message}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}


// B.js  子组件
import React, { Component } from &quot;react&quot;;
import PubSub from &quot;pubsub-js&quot;;
import C from &quot;./C&quot;;

export default class B extends Component {
  constructor(props) {
    super(props);
    this.state = {
      increase: &quot;B页面传值---------increase&quot;,
      decrease: &quot;B页面传值---------decrease&quot;,
    };
  }
  buttonIncrease() {
    PubSub.publish(&quot;PubSubmessage&quot;, this.state.increase);
  }
  buttonDecrease() {
    PubSub.publish(&quot;PubSubmessage&quot;, this.state.decrease);
  }
  render() {
    return (
      &lt;div style={{ color: &quot;red&quot; }}&gt;
        Page B: font color is Red
        &lt;br /&gt;
        This is Page B. Some state changes:
        &lt;button onClick={this.buttonIncrease.bind(this)}&gt;Increase&lt;/button&gt;
        &lt;button onClick={this.buttonDecrease.bind(this)}&gt;Decrease&lt;/button&gt;
        &lt;C&gt;&lt;/C&gt;
      &lt;/div&gt;
    );
  }
}

// C.js  孙子组件
import React, { Component } from &quot;react&quot;;
import PubSub from &quot;pubsub-js&quot;;
export default class C extends Component {
  constructor(props) {
    super(props);
    this.state = {
      increase: &quot;C页面传值---------increase&quot;,
      decrease: &quot;C页面传值---------decrease&quot;,
    };
  }
  buttonIncrease() {
    PubSub.publish(&quot;PubSubmessage&quot;, this.state.increase);
  }
  buttonDecrease() {
    PubSub.publish(&quot;PubSubmessage&quot;, this.state.decrease);
  }
  render() {
    return (
      &lt;div&gt;
        This is Page C. Some state changes:
        &lt;button onClick={this.buttonIncrease.bind(this)}&gt;Increase&lt;/button&gt;
        &lt;button onClick={this.buttonDecrease.bind(this)}&gt;Decrease&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre></div><h5 id="非嵌套组件通信"><a href="#非嵌套组件通信" class="header-anchor">#</a> 非嵌套组件通信</h5> <p><strong>自定义事件EventEmitter</strong></p> <div class="language- extra-class"><pre class="language-text"><code>npm install events --save
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 定义函数
emitter.addListener(funcName, func(args){})

// 调用函数传值
emitter.emit(funcName, args)
</code></pre></div><h3 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h3> <blockquote><ol><li>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code> 。</li> <li>class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener noreferrer">绑定<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code></li></ol></blockquote> <h4 id="绑定事件的几种方法"><a href="#绑定事件的几种方法" class="header-anchor">#</a> 绑定事件的几种方法</h4> <h5 id="在构造函数中使用bind绑定this"><a href="#在构造函数中使用bind绑定this" class="header-anchor">#</a> 在构造函数中使用bind绑定this</h5> <div class="language- extra-class"><pre class="language-text"><code>// render
&lt;button onClick={this.handleClick}&gt;
// constructor
this.handleClick = this.handleClick.bind(this);
</code></pre></div><h5 id="在调用的时候使用bind绑定this"><a href="#在调用的时候使用bind绑定this" class="header-anchor">#</a> 在调用的时候使用bind绑定this</h5> <div class="language- extra-class"><pre class="language-text"><code>// render
&lt;button onClick={this.handleClick.bind(this)}&gt;
</code></pre></div><h5 id="在调用的时候使用箭头函数绑定this"><a href="#在调用的时候使用箭头函数绑定this" class="header-anchor">#</a> 在调用的时候使用箭头函数绑定this</h5> <div class="language- extra-class"><pre class="language-text"><code>// render
&lt;button onClick={() =&gt; this.handleClick()}&gt;
</code></pre></div><h5 id="函数定义使用箭头函数"><a href="#函数定义使用箭头函数" class="header-anchor">#</a> 函数定义使用箭头函数</h5> <div class="language- extra-class"><pre class="language-text"><code>// render
&lt;button onClick={this.handleClick}&gt;
// 事件定义
handleClick = () =&gt; {
// 这里的this是组件的this
}
</code></pre></div><h4 id="事件流"><a href="#事件流" class="header-anchor">#</a> 事件流</h4> <p>在<code>React</code>的事件处理系统中，默认的事件流就是冒泡，如果希望以捕获的方式来触发事件的话，可以使用<code>onClickCapture</code>来绑定事件，也就是在事件类型后面加一个后缀<code>Capture</code></p> <h2 id="protal"><a href="#protal" class="header-anchor">#</a> protal</h2> <p>通过ReactDOM中的createPortal()方法，可以在渲染元素时将元素渲染到网页中的指定位置</p> <p><strong>使用情况</strong></p> <blockquote><p>需要在React中添加一个会盖住其他元素的Backdrop组件，Backdrop显示后，页面中所有的元素都会被遮盖。很显然这里需要用到定位，但是如果将遮罩层直接在当前组件中渲染的话，遮罩层会成为当前组件的后代元素。如果此时，当前元素后边的兄弟元素中有开启定位的情况出现，且层级不低于当前元素时，便会出现盖住遮罩层的情况。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const backdropDOM = document.getElementById('backdrop');

const Backdrop = () =&gt; {
  return ReactDOM.createPortal(
  &lt;div
           style={
      {
        position:'fixed',
        top:0,
        bottom:0,
        left:0,
        right:0,
        zIndex:9999,
        background:'rgba(0,0,0,.3)'
      }
    }
           &gt;
  &lt;/div&gt;,
      backdropDOM
  );
};
// Backdrop会直接渲染到网页中id为backdrop的div中
</code></pre></div><h2 id="全家桶"><a href="#全家桶" class="header-anchor">#</a> 全家桶</h2> <h3 id="router"><a href="#router" class="header-anchor">#</a> Router</h3> <h4 id="标签"><a href="#标签" class="header-anchor">#</a> 标签</h4> <h5 id="browserrouter"><a href="#browserrouter" class="header-anchor">#</a> BrowserRouter</h5> <p>Router的一种，通过使用HTML5提供的history API机制来维持页面UI通URL的统一</p> <p><strong>props</strong></p> <ul><li><p><code>basename</code>：该路由路径的base url。有前置斜杠，不能有后置斜杠。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;BrowserRouter basename=&quot;/calendar&quot;/&gt;
&lt;Link to=&quot;/today&quot;/&gt; // renders &lt;a href=&quot;/calendar/today&quot;&gt;
</code></pre></div></li> <li><p><code>getUserCOnfirmation</code>：路由跳转的二次确认函数，用来拦截Prompt组件，默认情况下使用window.confirm弹框  <strong>需要配合Prompt一起使用，没有Prompt不会弹出</strong></p></li> <li><p><code>forceRefresh</code>：布尔值。为true时, router在进行路由跳转的时候会进行页面刷新。<strong>可能只在浏览器不支持H5 history api的情况下需要使用。</strong></p></li> <li><p><code>keyLength</code>：自定义location.key的长度，默认为6  <strong>？？？？？？？</strong></p></li> <li><p><code>children</code>：需要渲染的<strong>单个reactNode元素组件</strong></p></li></ul> <h5 id="hashrouter"><a href="#hashrouter" class="header-anchor">#</a> HashRouter</h5> <p>通过URL hash部分，如location.hash来保持UI同URL一致。</p> <p><strong>hashRouter一般用于低版本浏览器，在较高版本浏览器中推荐配置服务器端使用browserHistory</strong></p> <p><strong>props</strong></p> <ul><li><code>basename</code></li> <li><code>getUserConfirmation</code></li> <li><code>hashType</code>：string，
<ul><li>&quot;slash&quot;- 创建像#/和的哈希#/sunshine/lollipops，默认</li> <li>&quot;noslash&quot;- 创建像#和的哈希#sunshine/lollipops</li></ul></li> <li><code>children</code></li></ul> <h5 id="link"><a href="#link" class="header-anchor">#</a> Link</h5> <p>进入页面路由的链接
<strong>props</strong></p> <ul><li><code>to</code></li> <li><code>replace</code>： 布尔值- 为true时，将会替换history stack中的当前路径</li></ul> <h5 id="navlink"><a href="#navlink" class="header-anchor">#</a> NavLink</h5> <p><code>&lt;Link&gt;</code> 的特殊版本，当匹配当前URL时，会给当前link添加样式。</p> <ul><li><code>activeClassName</code>：选中时添加的类名，默认为<code>active</code></li> <li><code>activeStyle</code>：对象，样式</li> <li><code>exact</code></li> <li><code>strict</code>：布尔值，为true时，当进行路由匹配时，后置斜杠将会被考虑在内</li> <li><code>isActive</code>：func。额外函数来进一步验证当前路由是否匹配</li></ul> <h5 id="route"><a href="#route" class="header-anchor">#</a> Route</h5> <p>React router中最重要的模块，主要职责是当location匹配路由时，会将UI <strong>render</strong>出来。</p> <p><strong>props</strong></p> <ul><li><code>to</code>： string, url地址</li> <li><code>to</code>： object,
<ul><li><code>pathname</code>：跳转路径</li> <li><code>search</code>：查询参数</li> <li><code>hash</code>：url中的hash, eg. #a-hash,</li> <li><code>state</code>：存储到location中的额外状态数据. location中的state可以在redirect跳转组件的<code>this.props.location.state</code>访问</li></ul></li> <li><code>push</code>： 为true表示redirect path将往history stack中推一条新数据而不是替换</li> <li><code>from</code>： redirect from url, 会进行正则匹配。只能用在<code>&lt;Switch&gt;</code>中</li> <li><code>exact</code>： bool, 精准匹配</li> <li><code>strict</code>： bool, 严格模式，后斜杠将考虑在内</li></ul> <h5 id="redirect"><a href="#redirect" class="header-anchor">#</a> Redirect</h5> <p>使用redirect将跳转到一个新的路由，新的location将会覆盖history stack中的当前location.</p> <p>使用场景：初始化时默认选中一个路由</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;Redirect to=&quot;/xxx&quot; /&gt;
</code></pre></div><h5 id="switch"><a href="#switch" class="header-anchor">#</a> Switch</h5> <p>渲染<code>Route</code>或<code>Redirect</code>中第一个匹配location的组件，且子元素只能为<code>Route</code>或<code>Redirect</code></p> <p>避免：不使用Switch时，如果有两个组件的path是同一个值，会同时展示（会一直匹配到最后一个Link，如果to一样，就显示）</p> <p>好处：使用Switch后，匹配到之后就不再继续之后的匹配，一般路径和组件是一一对应的，提高渲染效率</p> <p><strong>props</strong></p> <ul><li><code>location</code>：Object</li> <li><code>children</code>： 只能为<code>Route</code>或<code>Redirect</code></li></ul> <h5 id="prompt"><a href="#prompt" class="header-anchor">#</a> Prompt</h5> <p>当想阻止用户跳转路由，可以使用<code>prompt</code>提示用户是否跳转</p> <p><strong>props</strong></p> <ul><li><code>message</code>：提示的信息</li> <li><code>when</code>：布尔值，true表示弹出跳转提示框</li></ul> <h5 id="memoryrouter"><a href="#memoryrouter" class="header-anchor">#</a> MemoryRouter</h5> <p><code>Router</code>一种, 将url history保存在内存中，不可再页面地址栏中读取，通常用于测试或者非浏览器的环境，如react native</p> <h5 id="staticrouter"><a href="#staticrouter" class="header-anchor">#</a> StaticRouter</h5> <p>静态路由，页面的location 将不会改变。一般用于服务器端。</p> <h5 id="withrouter"><a href="#withrouter" class="header-anchor">#</a> withRouter</h5> <p><code>withRouter</code>的作用就是，如果我们某个东西不是一个<code>Router</code>，但是我们要依靠它去跳转一个页面，比如点击页面的logo 这时候就可以使用<code>withRouter</code>来做。</p> <p><strong>使用</strong></p> <p>将一个组件包裹进<code>Route</code>里面, 然后<code>react-router</code>的三个对象<code>history, location, match</code>就会被放进这个组件的<code>props</code>属性中。</p> <div class="language- extra-class"><pre class="language-text"><code>class Nav extends React.Component {
    constructor(){//跳转到
    	super(props);
     	console.log(this.props)
    }
    render() {
        return (
        	&lt;div&gt;{this.props.xxx}&lt;/div&gt;
        );
    }
}
export default withRouter(Nav);
</code></pre></div><p><img src="/notes/imgs/react/image-20201221104523737.png" alt="image-20201221104523737"></p> <h4 id="路由组件传参"><a href="#路由组件传参" class="header-anchor">#</a> 路由组件传参</h4> <h5 id="params"><a href="#params" class="header-anchor">#</a> params</h5> <div class="language- extra-class"><pre class="language-text"><code>// 注册
&lt;Route path={`${path}/:id/:msg`} /&gt;
// 传参
&lt;Link to={`${path}/123/456`} component={xxx}/&gt;
// 接收
this.props.match.params
// 结果
id=123  msg=456
</code></pre></div><h5 id="search"><a href="#search" class="header-anchor">#</a> search</h5> <div class="language- extra-class"><pre class="language-text"><code>// 注册
&lt;Route path={`${path}`} /&gt;
// 传参
&lt;Link to={`${path}/?id=123&amp;msg=456`} component={xxx}/&gt;
// 接收,通过插件querystring进行转换
this.props.location.search
// 结果
id=123  msg=456
</code></pre></div><h5 id="state-2"><a href="#state-2" class="header-anchor">#</a> state</h5> <div class="language- extra-class"><pre class="language-text"><code>// 传参
&lt;Link to={{path:`${path}/?id=123&amp;msg=456`,state:{id:123,msg:456}}} component={xxx}}/&gt;
// 注册
&lt;Route path={`${path}`} /&gt;
// 接收,通过插件querystring进行转换
this.props.location.state
</code></pre></div><h4 id="路由跳转改为replace模式"><a href="#路由跳转改为replace模式" class="header-anchor">#</a> 路由跳转改为replace模式</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;Route path={`${path}`} replace/&gt;
</code></pre></div><h4 id="编程式路由"><a href="#编程式路由" class="header-anchor">#</a> 编程式路由</h4> <h5 id="push"><a href="#push" class="header-anchor">#</a> push</h5> <blockquote><p>向history栈里面添加一条新记录</p></blockquote> <h5 id="replace"><a href="#replace" class="header-anchor">#</a> replace</h5> <blockquote><p>不会向 history 添加新记录</p></blockquote> <h5 id="go"><a href="#go" class="header-anchor">#</a> go</h5> <p><code>go(num)</code></p> <blockquote><p>大于0时：加载history中num个之后的URL</p> <p>小于0时：加载history中num个之前的URL</p></blockquote> <h5 id="goback"><a href="#goback" class="header-anchor">#</a> goBack</h5> <blockquote><p>加载history中前一个的URL</p></blockquote> <h5 id="gofoward"><a href="#gofoward" class="header-anchor">#</a> goFoward</h5> <blockquote><p>加载history中下一个的URL</p></blockquote> <h3 id="router6"><a href="#router6" class="header-anchor">#</a> Router6</h3> <h4 id="钩子函数"><a href="#钩子函数" class="header-anchor">#</a> 钩子函数</h4> <h6 id="usenavigate"><a href="#usenavigate" class="header-anchor">#</a> useNavigate</h6> <blockquote><p>编程式的路由跳转</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>navigate(pathname[,{replace: true, state: xxx}])
// pathname: 跳转路径
// pathname?key=value: search方式传参
// pathname/value: params方式传参，需要修改路由的path为'/login/:key'
// replace: true history.replceState，不设置时默认为history.pushState
// state: 传递state参数
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function App() {
	const navigate = useNavigate();
	
	const jumpLogin = () =&gt; {
		navigate('/login')
	}
	
	return (
		&lt;div&gt;
			&lt;button onClick={jumpLogin}&gt;&lt;/button&gt;
		&lt;/div&gt;
	)
}
</code></pre></div><h6 id="useparams"><a href="#useparams" class="header-anchor">#</a> useParams</h6> <blockquote><p>获取params参数</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const params = useParams()
console.log(params.key)
</code></pre></div><h6 id="usesearchparams"><a href="#usesearchparams" class="header-anchor">#</a> useSearchParams</h6> <blockquote><p>获取search参数</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const [search, setsearch] = useSearchParams()
console.log(search.get('name'))
console.log(search.get('age'))
</code></pre></div><h6 id="uselocation"><a href="#uselocation" class="header-anchor">#</a> useLocation</h6> <blockquote><p>获取state参数</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const state = useLocation()
console.log(state)
</code></pre></div><h6 id="useroutes"><a href="#useroutes" class="header-anchor">#</a> useRoutes</h6> <ul><li><p>路由配置</p> <div class="language- extra-class"><pre class="language-text"><code>import { Navigate } from 'react-router-dom';
import { lazy } from 'react';

import Home from '@/views/campus';

const handleLazy = (name: string) =&gt; {
    const Comp = lazy(() =&gt; import(`@/views/${name}`));
    return &lt;Comp /&gt;; //element需要传入&lt;Element /&gt;这种形式，与component不同
};

const routes = [
    {
        path: '/',
        element: &lt;Home /&gt;,
        children: [
            {
                path: '',
                element: handleLazy('overview')
            },
            {
                path: 'overview',
                element: handleLazy('overview')
            },
            {
                path: 'comprehensive',
                element: handleLazy('comprehensive')
            }
        ]
    },
    {
        path: '/login',
        element: handleLazy('login')
    },
    {
        path: '/404',
        element: handleLazy('404')
    },
    {
        path: '*',
        element: &lt;Navigate to='/404' /&gt;
    }
];

export default routes;
</code></pre></div></li> <li><p>路由使用</p> <div class="language- extra-class"><pre class="language-text"><code>function App() {
    const DRouter = useRoutes(DefaultRouter);
    return (
        &lt;Fragment&gt;
            {DRouter}
        &lt;/Fragment&gt;
    )
}

// 二级路由 &lt;Outlet&gt;&lt;/Outlet&gt;
import { Suspense } from 'react';
import { Outlet } from 'react-router-dom';

import layoutStyle from './index.module.scss';

import Menu from './menu';
import Side from './side';

function Layout() {
    return (
        &lt;div className={layoutStyle.layout}&gt;
            {/* 图表 */}
            &lt;Side&gt;
                &lt;Suspense fallback={&lt;h2&gt;Loading..&lt;/h2&gt;}&gt;&lt;Outlet /&gt;&lt;/Suspense&gt;
            &lt;/Side&gt;
            {/* 菜单 */}
            &lt;Menu /&gt;
        &lt;/div&gt;
    )
}
</code></pre></div></li></ul> <h3 id="redux-2"><a href="#redux-2" class="header-anchor">#</a> Redux</h3> <p><strong>Redux中的Store修改之后，React不会自动监听，也就是说页面不会重新渲染，需要手动进行监听</strong></p> <div class="language- extra-class"><pre class="language-text"><code>一般在最外层父组件中进行监听
componentDidMount(){
	store.subscribe(()=&gt;{
		this.setState({})
	})
}
</code></pre></div><h4 id="redux-3"><a href="#redux-3" class="header-anchor">#</a> Redux</h4> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from &quot;redux&quot;;
import { reducer } from &quot;./reducer&quot;

store = createStore(reducer)
</code></pre></div><h5 id="store"><a href="#store" class="header-anchor">#</a> store</h5> <p><img src="/notes/imgs/react/image-20201222150802906.png" alt="image-20201222150802906"></p> <h5 id="action"><a href="#action" class="header-anchor">#</a> action</h5> <ul><li><p>actionType</p> <div class="language- extra-class"><pre class="language-text"><code>export const ADD_TYPE = &quot;ADD_TYPE&quot;;
</code></pre></div></li> <li><p>index</p> <div class="language- extra-class"><pre class="language-text"><code>import * as actionType from &quot;./actionType&quot;;

export const add = (value) =&gt; {
  return {
    type: actionType.ADD_TYPE,
    title: &quot;这是 ADD_TYPE action&quot;,
    value,
  };
};
</code></pre></div></li></ul> <h5 id="reducer"><a href="#reducer" class="header-anchor">#</a> reducer</h5> <div class="language- extra-class"><pre class="language-text"><code>import * as actionType from &quot;../actionType&quot;;
const initState = {
  title: &quot;默认值&quot;,
};
export const reducer = (state = initState, action) =&gt; {
  let newState = {};
  switch (action.type) {
    case actionType.ADD_TYPE:
      newState = Object.assign({}, state, action);
      return newState;
    default:
      return state;
  }
};
</code></pre></div><h4 id="react-redux"><a href="#react-redux" class="header-anchor">#</a> React-Redux</h4> <h5 id="provider"><a href="#provider" class="header-anchor">#</a> Provider</h5> <blockquote><p>用于包裹整个结构，让每一层级的组件都能够获取到store</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;Provider store={store}&gt;
  &lt;div&gt;
    &lt;ComA&gt;&lt;/ComA&gt;
    &lt;ComB&gt;&lt;/ComB&gt;
  &lt;/div&gt;
&lt;/Provider&gt;
</code></pre></div><h5 id="connect"><a href="#connect" class="header-anchor">#</a> connect</h5> <div class="language- extra-class"><pre class="language-text"><code>class ComA extends React.Component {}
export default connect(mapStateToProps, mapDispatchToProps)(ComA)

// mapStateToProps和mapDispatchToProps是react-redux调用的，参数也是react-redux传的
// mapStateToProps
function mapStateToProps(state) {
	return state
}

// mapDispatchToprops
function mapDispatchToprops(dispatch) {
	// dispatch里面的add是action里面定义的add
	add: value =&gt; dispatch(add(value))
}

// mapDispatchToprops简写
let mapDispatchToprops = {
	add
}
</code></pre></div><h4 id="redux-toolkit-rtk"><a href="#redux-toolkit-rtk" class="header-anchor">#</a> Redux-toolkit  (RTK)</h4> <div class="language- extra-class"><pre class="language-text"><code>npm i @reduxjs/toolkit
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import { createSlice } from '@reduxjs/toolkit';

export const counterSlice = createSlice({
 	name: 'counter', // 命名空间，在调用action的时候会默认的设置为action的前缀
 	// 初始值
 	initialState: {
 		count: 1,
 		title: 'redux toolkit pre',
  	},
     // 这里的属性会自动的导出为actions，在组件中可以直接通过dispatch进行触发
     reducers: {
        increment(state, { payload }) {
            state.count = state.count + payload.step; // 内置了immutable
        },
        decrement(state) {
            state.count -= 1;
        },
      },
});

// 导出actions
export const { increment, decrement } = counterSlice.actions;

// 内置了thunk插件，可以直接处理异步请求
export const asyncIncrement = (payload) =&gt; (dispatch) =&gt; {
    setTimeout(() =&gt; {
        dispatch(increment(payload));
    }, 2000);
};

export default counterSlice.reducer; // 导出reducer，在创建store时使用到
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import './index.css';
import App from './App';
import store from './store';

ReactDOM.render(
	&lt;Provider store={store}&gt;
 		&lt;App /&gt;
	&lt;/Provider&gt;,
 	document.getElementById('root')
);
在组件内部，使用useState和useDispatch可以直接获取state数据与dispatch方法
import { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, asyncIncrement } from './store/features/counterSlice'; // 引入actions

function App() {
     const { count } = useSelector((state) =&gt; state.counter);
     const dispatch = useDispatch();
     return (
         &lt;div className='App'&gt;
             &lt;button
                 onClick={() =&gt; {
                    dispatch(increment({ step: 2 })); // dispatch派发action
                 }}
             &gt;
                {count}
             &lt;/button&gt;
            &lt;hr /&gt;
             &lt;button
                onClick={() =&gt; {
                    dispatch(asyncIncrement({ step: 1 }));
                }}
              &gt;
                  {count}
              &lt;/button&gt;
        &lt;/div&gt;
  );
}

export default App;
</code></pre></div><h3 id="mobx-redux-lite"><a href="#mobx-redux-lite" class="header-anchor">#</a> Mobx-Redux-lite</h3> <h4 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h4> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">npm</span> <span class="token function">install</span> mobx mobx-react-lite
</code></pre></div><h4 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// store/menu.ts</span>
<span class="token comment">// 创建一个store</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
    makeAutoObservable<span class="token punctuation">,</span>
    runInAction
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> MenuItem <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./types'</span>

<span class="token keyword">class</span> <span class="token class-name">MenuStore</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">menuData</span><span class="token operator">:</span> MenuItem<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">makeAutoObservable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">setMenuData</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">data</span><span class="token operator">:</span> MenuItem<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runInAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>menuData <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> menuStore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MenuStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> menuStore<span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// App.vue</span>
<span class="token comment">// 使用observer监听store</span>
<span class="token keyword">import</span> DefaultRouter <span class="token keyword">from</span> <span class="token string">'@/router'</span><span class="token punctuation">;</span> 
<span class="token keyword">import</span> <span class="token punctuation">{</span>
    useRoutes<span class="token punctuation">,</span> useNavigate<span class="token punctuation">,</span> useLocation  
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> observer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'mobx-react-lite'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> PubSub <span class="token keyword">from</span> <span class="token string">'pubsub-js'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> navigate <span class="token operator">=</span> <span class="token function">useNavigate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> location <span class="token operator">=</span> <span class="token function">useLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> whiteList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'/overview'</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>whiteList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">navigate</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment">// 监听当前 location改变</span>
    <span class="token comment">// topic: string, route: string</span>
    PubSub<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">'changeRoute'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">topic</span><span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">route</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">navigate</span><span class="token punctuation">(</span>route<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">replace</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">useRoutes</span><span class="token punctuation">(</span>DefaultRouter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 将 store 对象传递给组件</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">observer</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用store</span>
<span class="token keyword">import</span> menuStore <span class="token keyword">from</span> <span class="token string">'@/store/menu'</span><span class="token punctuation">;</span>
menuStore<span class="token punctuation">.</span><span class="token function">setMenuData</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="创建可观察状态"><a href="#创建可观察状态" class="header-anchor">#</a> 创建可观察状态</h4> <ul><li>makeObservable</li> <li>makeAutoObservable：自动推断所有属性</li></ul> <h2 id="reacthooks"><a href="#reacthooks" class="header-anchor">#</a> reactHooks</h2> <blockquote><p>在函数组件中使用state，生命周期</p></blockquote> <ul><li>只能用于函数组件或自定义的钩子函数中</li> <li>只能直接在函数组件中使用，函数组件的方法中不行</li></ul> <h3 id="常用hooks"><a href="#常用hooks" class="header-anchor">#</a> 常用Hooks</h3> <h4 id="usestate"><a href="#usestate" class="header-anchor">#</a> useState</h4> <p><code>const [state, setState] = useState(initialState);</code></p> <p>返回一个state，以及更新state的函数</p> <p>在初始渲染期间，返回的状态 (<code>state</code>) 与传入的第一个参数 (<code>initialState</code>) 值相同。</p> <p><strong>注意：</strong></p> <ol><li><p>如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。</p></li> <li><p>与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象</p> <p><a href="#useReducer">useReducer</a> 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p></li></ol> <h4 id="useeffect"><a href="#useeffect" class="header-anchor">#</a> useEffect</h4> <p><code>useEffect(didUpdate);</code></p> <blockquote><p><em>Effect Hook</em> 可以让你在函数组件中执行副作用操作</p></blockquote> <blockquote><p>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p></blockquote> <p>副作用操作的例子：</p> <p><img src="/notes/imgs/react/react-%E5%89%AF%E4%BD%9C%E7%94%A8.png" alt="image-20230201153745912"></p> <div class="language- extra-class"><pre class="language-text"><code>const ThemeContext = React.createContext({
  theme: 'dark',
  toggle: () =&gt; {}, //向上下文设定一个回调方法
  clear: () =&gt; {}
});

function App() {
	const [theme, setTheme] = useState('dark');
	const toggle = () =&gt; setTheme(theme === 'dark' ? 'light' : 'dark');
	const clear = () =&gt; setTheme('');
	return (
		&lt;ThemeContext.Provider value={{theme, toggle, clear}}&gt;
            &lt;Content /&gt;
          &lt;/ThemeContext.Provider&gt;
    );
}

function Content() {
    const {toggle, clear, theme} = useContext(ThemeContext);
    const [count, setCount] = useState(0);
    if (!theme) setCount(1);
    return (
    	&lt;Fragment&gt;
    		&lt;button onClick={toggle}&gt;修改theme&lt;/button&gt;
    		&lt;button onClick={clear}&gt;清空theme&lt;/button&gt;
    	&lt;/Fragment&gt;
    )
}

// 当theme被清空时，调用了setCount，再一次触发了重新渲染，会重新进入if判断，导致死循环
</code></pre></div><h5 id="可以作为类似于生命周期使用"><a href="#可以作为类似于生命周期使用" class="header-anchor">#</a> 可以作为类似于生命周期使用</h5> <ul><li>第一个参数：函数，该函数内的逻辑视为<code>componentDidMount</code>；如果该函数有函数返回值，视为<code>componentWillUnmount</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// useEffect返回一个清除函数
useEffect(() =&gt; {
  // componentDidMount 
  const subscription = props.source.subscribe();
  return () =&gt; {
    // componentWillUnmount
    subscription.unsubscribe();
  };
});
</code></pre></div><ul><li>第二个参数</li></ul> <ol><li><p>没有第二个参数：组件的初始化和更新都会执行</p> <div class="language- extra-class"><pre class="language-text"><code>useEffect(() =&gt; {
  // componentDidMount componentDidUpdate
  // ...
});
</code></pre></div></li> <li><p>空数组：初始化调用一次之后不再执行，相当于componentDidMount</p> <div class="language- extra-class"><pre class="language-text"><code>// 解决上面的副作用
// ...
function Content() {
    const {
        toggle, clear, theme 
    } = useContext(ThemeContext);
    const [count, setCount] = useState(0);
    useEffect(() =&gt; {
        console.log('useEffect', count)
        if (!theme) setCount(1);
    });
    // ...
}
</code></pre></div></li> <li><p>有一个值：初始化时和该值改变时会执行，相当于componentDidMount，componentDidUpdate</p></li> <li><p>有多个值：对比每个值，其中一个有变化时执行</p></li></ol> <h4 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h4> <p><code>const refContainer = useRef(initialValue);</code></p> <h5 id="和createref的区别"><a href="#和createref的区别" class="header-anchor">#</a> 和createRef的区别</h5> <ul><li>createRef会在组件每次渲染的时候重新创建</li> <li>useRef只会在组件首次渲染时创建</li></ul> <h5 id="作用于普通组件时"><a href="#作用于普通组件时" class="header-anchor">#</a> 作用于普通组件时</h5> <p>作用于普通组件时，与createRef的用法是一样的</p> <div class="language- extra-class"><pre class="language-text"><code>import { Input, Button } from 'antd';
import { useRef, createRef } from 'react';

import type { InputRef } from 'antd';

const RefDemo = () =&gt; {
  const inputEL = useRef&lt;InputRef&gt;(null);
  const inputEL2 = useRef&lt;HTMLInputElement&gt;(null);
  const inputEL3 = createRef&lt;HTMLInputElement&gt;();

  const getInput = () =&gt; {
    console.log('antd DOM', inputEL.current?.input?.value);
    console.log('原生 DOM', inputEL2.current?.value);
    console.log('createRef', inputEL3.current?.value);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;antd Input：&lt;Input ref={inputEL} style={{width: 167}} /&gt;&lt;/p&gt;
      &lt;p&gt;原生 Input：&lt;input type=&quot;text&quot; ref={inputEL2} /&gt;&lt;/p&gt;
      &lt;p&gt;createRef Input：&lt;input type=&quot;text&quot; ref={inputEL3} /&gt;&lt;/p&gt;
      &lt;p&gt;&lt;Button onClick={getInput}&gt;获取Input Value&lt;/Button&gt;&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default RefDemo;
</code></pre></div><h5 id="调用子组件的方法-获取子组件"><a href="#调用子组件的方法-获取子组件" class="header-anchor">#</a> 调用子组件的方法/获取子组件</h5> <p>需要用到两个方法 <code>useImperativeHandle</code> 和 <code>forwardRef</code></p> <h6 id="forwardref"><a href="#forwardref" class="header-anchor">#</a> <code>forwardRef</code></h6> <blockquote><p>引用传递（Ref forwading）是一种通过组件向子组件自动传递 <strong>引用ref</strong> 的技术。对于应用者的大多数组件来说没什么作用。但是对于有些重复使用的组件，可能有用。例如某些input组件，需要控制其focus，本来是可以使用ref来控制，但是因为该input已被包裹在组件中，这时就需要使用Ref forward来透过组件获得该input的引用。</p></blockquote> <h6 id="useimperativehandle"><a href="#useimperativehandle" class="header-anchor">#</a> <code>useImperativeHandle</code></h6> <blockquote><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。</p> <p>在大多数情况下，应当避免使用 ref 这样的命令式代码。</p> <p>useImperativeHandle 应当与 <strong>forwardRef</strong> 一起使用。</p></blockquote> <p><code>useImperativeHandle(ref, createHandle, [deps])</code></p> <div class="language- extra-class"><pre class="language-text"><code>// 调用子组件的方法
import React, { useRef, useImperativeHandle,forwardRef } from 'react';
import ReactDOM from 'react-dom';

const FancyInput = forwardRef((props, ref) =&gt; {
  const inputRef = useRef();
  useImperativeHandle(ref, () =&gt; ({
    focus: () =&gt; {
      inputRef.current.focus();
    }
  }));

  return &lt;input ref={inputRef} type=&quot;text&quot; /&gt;
});

const App = props =&gt; {
  const fancyInputRef = useRef();

  return (
    &lt;div&gt;
      &lt;FancyInput ref={fancyInputRef} /&gt;
      &lt;button
        onClick={() =&gt; fancyInputRef.current.focus()}
      &gt;父组件调用子组件的 focus&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 获取子组件
import React, { useRef,forwardRef } from 'react';
import ReactDOM from 'react-dom';

const FancyInput = forwardRef((props, ref) =&gt; (
	&lt;input ref={ref} type=&quot;text&quot; value={props.children}/&gt;
));

const App = props =&gt; {
  const fancyInputRef = useRef();

  return (
    &lt;div&gt;
      &lt;FancyInput ref={fancyInputRef}&gt;hhtest&lt;/FancyInput&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre></div><h3 id="其他hooks"><a href="#其他hooks" class="header-anchor">#</a> 其他Hooks</h3> <h4 id="usereducer"><a href="#usereducer" class="header-anchor">#</a> useReducer</h4> <p><a href="#useState">useState</a>的替代方案，在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p> <p>使用：</p> <div class="language- extra-class"><pre class="language-text"><code>import {useReducer} from 'react';

function App() {
    const reducer = (state, action) =&gt; {
        switch(action.type){
            case 'add':
                return state + 1;
            case 'sub':
                return state - 1;
        }
    };
    
    const [count, countDispath] = useReducer(reducer, 1);
    
    return (
        &lt;div className=&quot;App&quot;&gt;
            {count}
            &lt;div&gt;
                &lt;button onClick={()=&gt;countDispath({type:'sub'})}&gt;-&lt;/button&gt;
                &lt;button onClick={()=&gt;countDispath({type:'add'})}&gt;+&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}
</code></pre></div><h4 id="usememo"><a href="#usememo" class="header-anchor">#</a> useMemo</h4> <div class="language- extra-class"><pre class="language-text"><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
</code></pre></div><h5 id="react-memo"><a href="#react-memo" class="header-anchor">#</a> React.memo</h5> <p>减少不必要的重新渲染，比如App-&gt;A-&gt;B，当App重新渲染时，A和B都会重新渲染。但B组件没有state、context、props，没有必要每次都重新渲染，此时可以用到<code>React.memo</code>方法</p> <p>在B组件中使用，<code>React.memo(B)</code></p> <p><strong>useMemo和<a href="#useCallback">useCallback</a>作用和用法是一样的</strong></p> <h4 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> useCallback</h4> <p>用来创建React中的回调函数，该回调函数仅在某个依赖项改变时才会更新</p> <p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p> <ul><li>第二个参数：不指定时，每次都会更新；指定时，其中某个变化时才会更新</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const memoizedCallback = useCallback(
  () =&gt; {
    doSomething(a, b);
  },
  [a, b],
);
</code></pre></div><p>可以解决<a href="#React.memo">React.memo</a>的遗留问题，如果B组件中某个按钮点击触发了A组件的事件，A组件更新时，B组件仍然会更新</p> <h5 id="usememo、usecallback的区别"><a href="#usememo、usecallback的区别" class="header-anchor">#</a> useMemo、useCallback的区别</h5> <ul><li>useCallback 和 useMemo 的区别</li></ul> <p>​	<code>useCallback</code>返回一个函数，当把它返回的这个函数作为子组件使用时，可以避免每次父组件更新时都重新渲染这个子组件；<code>useMemo</code>返回的的是一个值，用于避免在每次渲染时都进行高开销的计算。</p> <h4 id="usecontext"><a href="#usecontext" class="header-anchor">#</a> useContext</h4> <p>​	如果需要在组件之间共享状态，可以使用useContext()。和<a href="#context%E5%AF%B9%E8%B1%A1">Context.Consumer</a>一样</p> <div class="language- extra-class"><pre class="language-text"><code>//接收组件
function Button() {
	const {theme, toggle} = useContext(ThemeContext);
  	return (
        &lt;button
          onClick={toggle} //调用回调
          style={{backgroundColor: theme}}
        &gt;
          Toggle Theme
        &lt;/button&gt;
  	);
}

// 等价于
// Context.Consumer
//接收组件
function Button() {
  return (
    &lt;ThemeContext.Consumer&gt;
      {({theme, toggle}) =&gt; (
        &lt;button
          onClick={toggle} //调用回调
          style={{backgroundColor: theme}}&gt;
          Toggle Theme
        &lt;/button&gt;
      )}
    &lt;/ThemeContext.Consumer&gt;
  );
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.1087d36c.js" defer></script><script src="/notes/assets/js/2.c60e90e7.js" defer></script><script src="/notes/assets/js/15.cfd3f1d4.js" defer></script>
  </body>
</html>
