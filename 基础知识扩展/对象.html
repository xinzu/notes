<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>yh的学习文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/notes/assets/css/0.styles.aa6162e3.css" as="style"><link rel="preload" href="/notes/assets/js/app.c0270f27.js" as="script"><link rel="preload" href="/notes/assets/js/2.c60e90e7.js" as="script"><link rel="preload" href="/notes/assets/js/27.6d5b0d55.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.43f9523c.js"><link rel="prefetch" href="/notes/assets/js/11.7dcdc7ad.js"><link rel="prefetch" href="/notes/assets/js/12.4d31b76d.js"><link rel="prefetch" href="/notes/assets/js/13.74f0fd18.js"><link rel="prefetch" href="/notes/assets/js/14.78e6d811.js"><link rel="prefetch" href="/notes/assets/js/15.aaea5d7b.js"><link rel="prefetch" href="/notes/assets/js/16.5d640bd3.js"><link rel="prefetch" href="/notes/assets/js/17.ef2758f7.js"><link rel="prefetch" href="/notes/assets/js/18.584d5888.js"><link rel="prefetch" href="/notes/assets/js/19.7195c25f.js"><link rel="prefetch" href="/notes/assets/js/20.ed256560.js"><link rel="prefetch" href="/notes/assets/js/21.22b59e64.js"><link rel="prefetch" href="/notes/assets/js/22.0f93036f.js"><link rel="prefetch" href="/notes/assets/js/23.514e44e7.js"><link rel="prefetch" href="/notes/assets/js/24.07131156.js"><link rel="prefetch" href="/notes/assets/js/25.4f6379f2.js"><link rel="prefetch" href="/notes/assets/js/26.097476c0.js"><link rel="prefetch" href="/notes/assets/js/28.e848ad80.js"><link rel="prefetch" href="/notes/assets/js/29.1586d5cc.js"><link rel="prefetch" href="/notes/assets/js/3.0cf10e4b.js"><link rel="prefetch" href="/notes/assets/js/30.66536310.js"><link rel="prefetch" href="/notes/assets/js/31.8242b594.js"><link rel="prefetch" href="/notes/assets/js/32.bf01d0ae.js"><link rel="prefetch" href="/notes/assets/js/33.dffd180d.js"><link rel="prefetch" href="/notes/assets/js/4.b7d0708f.js"><link rel="prefetch" href="/notes/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/notes/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/notes/assets/js/7.a47336e3.js"><link rel="prefetch" href="/notes/assets/js/8.fb5a3d35.js"><link rel="prefetch" href="/notes/assets/js/9.d7d00d31.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.aa6162e3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">yh的学习文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础知识扩展</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/基础知识扩展/对象.html" class="active sidebar-link">对象</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/notes/基础知识扩展/对象迭代的方法.html" class="sidebar-link">对象迭代的方法</a></li><li><a href="/notes/基础知识扩展/正则.html" class="sidebar-link">正则</a></li><li><a href="/notes/基础知识扩展/存储机制.html" class="sidebar-link">存储机制</a></li><li><a href="/notes/基础知识扩展/禁用弹出框后退页面.html" class="sidebar-link">禁用弹出框后退页面</a></li><li><a href="/notes/基础知识扩展/强制360浏览采用哪种内核.html" class="sidebar-link">强制360浏览采用哪种内核</a></li><li><a href="/notes/基础知识扩展/setTimeout.html" class="sidebar-link">setTimeout</a></li><li><a href="/notes/基础知识扩展/单行代码.html" class="sidebar-link">数组-单行代码</a></li><li><a href="/notes/基础知识扩展/宏任务和微任务.html" class="sidebar-link">宏任务和微任务</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>http</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/notes/typescript/ts.html" class="sidebar-link">typescript</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具类</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>第六章  面向对象的程序设计</p> <h3 id="认识对象"><a href="#认识对象" class="header-anchor">#</a> 认识对象</h3> <p>什么是对象  <code>无序属性的集合，其属性可以包含基本值、对象或者函数</code> <code>哈希表</code></p> <h4 id="_1-属性类型"><a href="#_1-属性类型" class="header-anchor">#</a> 1. 属性类型</h4> <p>对象在创建时都带有一些特征值 【es5 中使用属性描述了这些特性】【定义行为】</p> <p>属性分为两种属性，不同的属性拥有不同的特征  <code>数据属性</code>，<code>访问器属性</code></p> <p><code>数据属性</code>： 一般我们直接定义赋值的都是数据属性</p> <p>数据属性有四个描述其行为的特征：可删除，for-in可遍历，可修改，数据值</p> <p>默认 ：  [[<code>Configurable</code>]] 、 [[<code>Enumerable</code> ]] 、  [[ <code>Writable</code> ]]   默认为 <code>true</code></p> <p>​				 [[ <code>Value</code> ]] 默认为   <code>undefined</code></p> <p>要修改默认的特征可以调用 <code>Object.defineProperty()</code>这个方法</p> <p>在调用<code>Object.defineProperty()</code>方法创建一个新的属性时[描述符对象]，如果不指定，<code>configurable</code>、<code>enumerable</code>、<code>writable</code> 特性的默认值都是 false</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">//普通的属性 赋值 读取 </span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string-property property">'b'</span><span class="token operator">:</span><span class="token string">'c'</span><span class="token punctuation">}</span>

a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token comment">// 内部属性 赋值读取 </span>
<span class="token comment">// 有一些内置属性具有指定的特征</span>
<span class="token comment">// Math.PI  此值就不可以修改</span>

Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">10</span> 

<span class="token comment">// 修改特征 </span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//  三个参数  属性所在的对象 ，属性的名字 和 一个描述符对象</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token comment">// 不能修改值</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'张三'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 张三</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'李四'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 张三,  writable设为 false 后，值就没法修改了。</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'李四'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">24</span>
<span class="token punctuation">}</span>

<span class="token keyword">delete</span> person<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {age: 24}</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">delete</span> person<span class="token punctuation">.</span>age<span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// {age: 24} configurable特性设为 false 后，就没法使用 delete 删除了。</span>

<span class="token comment">// 注意： ie8 是第一个实现 Object.definePerporty方法的浏览器,但是不成熟，所以不要在ie8 中使用</span>
</code></pre></div><p><code>访问器属性</code>   :    包含一对 getter  setter 函数 (都<code>不是必须</code>的) 。允许用户在赋值或取值都经过预先设定的函数，从而实现内部属性的那一种特殊效果。</p> <p>同样具有四个特征；</p> <p>可删除，可遍历，get时调用的函数，set时调用的函数</p> <p><code>默认</code>  true,true,undefined,undefined</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">_year</span> <span class="token operator">:</span> <span class="token number">2004</span><span class="token punctuation">,</span><span class="token comment">//_year前面下划线是常用的记号，表示只能通过对象方法访问的属性</span>
    <span class="token literal-property property">edition</span> <span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// year 就是访问器属性 </span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span><span class="token string">&quot;year&quot;</span><span class="token punctuation">,</span><span class="token punctuation">{</span> 
    <span class="token function-variable function">get</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

book<span class="token punctuation">.</span>year  即调用 <span class="token keyword">get</span> 方法  赋值的时候 就调用 <span class="token keyword">set</span> 方法 
<span class="token comment">// 我们当前的 vue 就是使用这个方法，来保证 数据双向绑定</span>

</code></pre></div><p>2.定义多个属性</p> <p><code>Object.defineProperties()</code> 可以通过描述符一个定义多个属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 接收两个参数  添加属性的对象  包含多个需要添加和修改的属性的对象</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token string-property property">&quot;year&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span> 
        <span class="token function-variable function">get</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">set</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">10</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_3-读取属性的特性"><a href="#_3-读取属性的特性" class="header-anchor">#</a> 3.读取属性的特性</h5> <p><code>getOwnPropertyDescriptor</code></p> <h3 id="创建对象"><a href="#创建对象" class="header-anchor">#</a> 创建对象</h3> <h5 id="_1-object"><a href="#_1-object" class="header-anchor">#</a> 1. Object</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><code>缺点</code>   使用同一个接口创建很多对象，产生大量代码</p> <h5 id="_2-字面量"><a href="#_2-字面量" class="header-anchor">#</a> 2.字面量</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span>  a<span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">b</span><span class="token operator">:</span>c<span class="token punctuation">}</span>
</code></pre></div><p><code>缺点</code>   使用同一个接口创建很多对象，产生大量代码</p> <h5 id="_3-工厂模式"><a href="#_3-工厂模式" class="header-anchor">#</a> 3.工厂模式</h5> <p><code>原理</code>  发明一种函数 分装特定接口 返回一个对象   （通过函数 生成特定对象）</p> <p><code>优点</code>  解决代码重复</p> <p><code>缺点</code>  无法解决对象识别的问题   (产生的都是原生对象的实例)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> createPerson （name<span class="token punctuation">,</span>age）<span class="token punctuation">{</span>
  	<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token punctuation">;</span> 
    o<span class="token punctuation">.</span>age<span class="token operator">=</span> age<span class="token punctuation">;</span>  
    o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>   
<span class="token comment">//多次调用 返回一个对象   无法识别这个对象是谁创建的</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'ss'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h5 id="_4-构造函数模式"><a href="#_4-构造函数模式" class="header-anchor">#</a> 4.构造函数模式</h5> <p><code>原理</code>   构造函数可以用来创建特定类型的对象</p> <p><code>优点</code>  特性 可以通过constructor 标识对象类型</p> <p><code>缺点</code>   构造函数中包含方法时  每生成一个新的对象 这个对象中就包含一个新的同名的方法（浪费内存） 实际上没有必要在 执行代码前就把 完成相同任务的方法 绑定在特定对象上</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token punctuation">;</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span> age<span class="token punctuation">;</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>   

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'ss'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 方法没有公用</span>

<span class="token comment">//与工厂模式不同</span>
<span class="token number">1.</span> 没有显示的创建对象
<span class="token number">2.</span> 直接将属性和方法赋值给 <span class="token keyword">this</span> 对象
<span class="token number">3.</span> 没有<span class="token keyword">return</span> 语句

</code></pre></div><p><code>new</code> 操作符的运行过程</p> <ol><li><p>创建一个新对象</p></li> <li><p>将构造函数的作用域赋给新对象 （因此 this 指向这个对象）</p></li> <li><p>执行构造函数代码</p></li> <li><p>返回新对象</p></li></ol> <p>简单实现一个<code>new</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 调用构造函数 </span>

<span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token parameter">Con<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//创建对象</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 构造函数的原型 创建的对象进行原型关联  即为 对象的 __proto__  属性 指向原型对象</span>
  <span class="token comment">// obj.__proto__ = Con.prototype;</span>
  Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token class-name">Con</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  <span class="token comment">// 运行函数</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">Con</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
  <span class="token comment">// 返回对象 </span>
  <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj
<span class="token punctuation">}</span>

</code></pre></div><p><code>constructor(构造函数属性)</code> : 用来标识对象类型</p> <p><code>instanceof</code>操作符   <code>instanceof</code> 并不关心构造函数，它真正关心的是原型链。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span> <span class="token keyword">instanceof</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</p> <p><code>构造函数</code>只要使用new 操作符 调用的就是构造函数  不使用它调用的时候 就是普通函数</p> <p>5.原型模式</p> <p><code>原理</code>  每个函数都有一个prototype 的属性 ， 此属性是一个指针，指向一个对象（包含特定类型的所有实例共享的属性和方法）  指向的对象 可以说是 实例的原型对象</p> <p><code>优点</code>   共享所有原型对象包含的属性和方法</p> <p><code>缺点</code>  原型中所有属性都是被很多实例所共享的， 但是基本类型的属性没有问题 但是所有实例同名引用属性的值都会指向一个地方</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//</span>
<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;p1&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">&quot;female&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
function Person () {
}

	Person.prototype.name = &quot;p1&quot;;
    Person.prototype.age = 10;
    Person.prototype.sex = &quot;female&quot;;
    Person.prototype.sayName =function(){
        console.log(this.name);
    }
    
    
------
function Person () {
}
// 重写  没有construtor
	Person.prototype= {
	//construtor：
		name ： &quot;p1&quot;,
		age ： 10,
		sex : &quot;female&quot;,
		sayName : function(){
        	console.log(this.name);
   	 	}
	}

*/</span>

<span class="token keyword">var</span> per1 <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> per2 <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototyeOf</span><span class="token punctuation">(</span>per1<span class="token punctuation">)</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototyeOf</span><span class="token punctuation">(</span>per2<span class="token punctuation">)</span>
</code></pre></div><p><code>原型对象</code></p> <ol><li>任何时候只要创建新函数，就会为该函数创建一个<code>prototype</code>属性，此属性指向原型对象</li> <li>所有原型对象自动获得一个<code>construtor</code>构造函数属性    其他方式 的这个值有嘛</li></ol> <p><code>isPrototypeOf</code> 确定对象之间是否存在关系</p> <p><code>getPrototypeOf</code> 获取对象的_ <em>proto</em> _ 属性的值</p> <p><code>原型链查找</code> 从对象实例本身开始--原型对象</p> <p><code>同名属性</code> 不能被覆盖只能被屏蔽    有不能被屏蔽的时候</p> <p><code>hasOwnProperty</code> 检测属性在原型中还是当前实例中</p> <p><code>in</code>只要能访问就返回true</p> <p>for  in</p> <h5 id="_5-组合使用构造函数和原型模式"><a href="#_5-组合使用构造函数和原型模式" class="header-anchor">#</a> 5.组合使用构造函数和原型模式</h5> <p>此为最常见方法</p> <p><code>原理</code></p> <ol><li>使用构造函数 定义实例专有属性</li> <li>使用原型模式定义方法和共享属性</li></ol> <p><code>缺点</code> 独立的构造函数和原型  不利于代码的可读性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'aa'</span><span class="token punctuation">,</span> <span class="token string">'bb'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span>Person<span class="token punctuation">,</span>
    <span class="token function-variable function">SayName</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Enginner&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;lisi&quot;</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token string">&quot;Doctor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'cc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//aa, bb, cc</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// aa, bb</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends <span class="token operator">===</span> person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> person2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//true</span>


</code></pre></div><h5 id="_6-动态原型模式"><a href="#_6-动态原型模式" class="header-anchor">#</a> 6.动态原型模式</h5> <p><code>原理</code>   通过构造函数初始化原型  有点像单例模式</p> <p><code>缺点</code> 独立的构造函数和原型  不利于代码的可读性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">;</span>
    <span class="token comment">// </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">!=</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;la&quot;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">&quot;man&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_7-寄生构造函数模式"><a href="#_7-寄生构造函数模式" class="header-anchor">#</a> 7. 寄生构造函数模式</h5> <p>在前几种模式不适用的情况下 使用该模式</p> <p>在特殊情况下为对象创建构造函数 ？</p> <p><code>原理</code>   创建一个函数，分装创建对象的代码，返回新对象  长得和工厂模式一模一样</p> <h5 id="_8-稳妥构造函数"><a href="#_8-稳妥构造函数" class="header-anchor">#</a> 8.  稳妥构造函数</h5> <p>没有公共属性，安全模式中使用 ，不适用this</p> <h5 id="_9-es6-class"><a href="#_9-es6-class" class="header-anchor">#</a> 9.es6 class</h5> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//一种定义构造函数及其原型方法的语法糖</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  <span class="token comment">// class 方法</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
  
  <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 类是函数</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> User<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function</span>

<span class="token comment">// ...或者，更确切地说是构造方法</span>
<span class="token function">alert</span><span class="token punctuation">(</span>User <span class="token operator">===</span> <span class="token class-name">User</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// User.prototype 中的方法，比如：</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayHi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// alert(this.name);</span>

<span class="token comment">// 实际上在原型中有两个方法</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// constructor, sayHi</span>
<span class="token comment">// 测试枚举             </span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> a <span class="token keyword">in</span> u <span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span>             
</code></pre></div><p>Es5 实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以纯函数的重写 User 类</span>

<span class="token comment">// 1. 创建构造器函数</span>
<span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 任何函数原型默认具有构造器属性，</span>
<span class="token comment">// 所以，我们不需要创建它</span>

<span class="token comment">// 2. 向原型中添加方法</span>
<span class="token class-name">User</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用方法：</span>
<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>// 访问器属性 es6</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 setter</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Name is too short.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span>
</code></pre></div><p>//es5</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             
</code></pre></div><p>区别</p> <ol start="2"><li>类方法不可枚举   es6</li> <li>类默认使用 use strict  在类构造函数中的所有方法自动使用严格模式。</li> <li>可以直接写 访问器属性</li> <li></li></ol> <h3 id="对象继承"><a href="#对象继承" class="header-anchor">#</a> 对象继承</h3> <h5 id="_1-理解原型链"><a href="#_1-理解原型链" class="header-anchor">#</a> 1. 理解原型链</h5> <ol><li><p>所有引用类型（函数、对象、数组），都存在对象特性，即可以自由拓展属性。<strong>（除了null以外）</strong></p></li> <li><p>所有的引用类型（函数、对象、数组），都有一个<code>__proto__</code>(我们这里称他为<em>隐形原型</em>)属性，属性值是一个普通的对象。</p></li> <li><p>所有<strong>函数</strong>都有一个prototype属性，属性值也是一个普通的函数</p></li> <li><p>所有的引用类型（函数、对象、数组），<em>*proto</em><em>属性值指向它的<strong>构造函数的 prototype</strong>(显性属性)属性值。</em></p></li> <li><p>*当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_<em>proto_</em>（即他的构造函数的prototype）中寻找。如果没有，则会接着往上找，一直上溯到Object.prototype，也就是说所有对象都继承Object.prototype的属性，Object.prototype的原型是null，null没有任何属性和方法。</p></li></ol> <p>构造函数、原型和实例的关系</p> <ol><li>每个构造函数（函数）都有一个原型对象 <code>prototype</code></li> <li>原型对象都包含一个指向构造函数的指针 <code>construtor</code></li> <li>而实例都包含一个指向原型对象的内部指针<code>__proto__</code>    实例的 <code>__proto__</code> 指向构造函数的 <code>prototype</code></li></ol> <p>把一个对象的<code>__proto__</code>指向另一个原型对象,而这个原型对象的<code>__proto__</code>又会指向另一个原型对象，这些就会形成原型链</p> <p>特殊的Function</p> <ul><li>函数都是由Function构造出来的，Function作为函数，是由其自身构建出来，故Function的原型指针指向其自身的原型对象。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token punctuation">;</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span> age<span class="token punctuation">;</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span>class <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'en'</span><span class="token punctuation">,</span><span class="token string">'math'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>   

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>like <span class="token operator">=</span> <span class="token string">'fruit'</span><span class="token punctuation">;</span>
</code></pre></div><p>继承 我们需要继承什么？</p> <p>继承的最终目的 ：用最少的代码 可以实现继承公有属性和方法的同时，拥有自己的属性和方法</p> <h5 id="_2-原型链继承"><a href="#_2-原型链继承" class="header-anchor">#</a> 2.原型链继承</h5> <p><code>原理</code> 让新实例的原型等于父类的实例</p> <p><code>优点</code>  实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）</p> <p><code>缺点</code></p> <p>1.新实例无法向父类构造函数传参。</p> <p>2.继承单一。只能继承一个父类</p> <p>3.所有新实例都会共享父类原型的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Per</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Per</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Per</span><span class="token punctuation">(</span><span class="token string">&quot;la&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> per2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Per</span><span class="token punctuation">(</span><span class="token string">&quot;la&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

per2<span class="token punctuation">.</span>class<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'ss'</span><span class="token punctuation">)</span> <span class="token comment">// </span>

per<span class="token punctuation">.</span>class <span class="token comment">//</span>

</code></pre></div><p><code>per.__proto__ --&gt; (Per.prototype = new Person)</code> <code>Per.prototype.__proto__--&gt;Person.prototype</code> <code>Person.prototype.__proto__ --&gt;Object.prototype</code> <code>Object.prototype.__proto__ --&gt; null</code></p> <h5 id="_3-借用构造函数继承-伪造对象-或经典继承"><a href="#_3-借用构造函数继承-伪造对象-或经典继承" class="header-anchor">#</a> 3.借用构造函数继承   伪造对象 或经典继承</h5> <p><code>原理</code>  用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</p> <p><code>优点</code>传递参数</p> <p>1、只继承了父类构造函数的属性，没有继承父类原型的属性。</p> <p>2、解决了原型链继承缺点1、2、3。</p> <p>3、可以继承多个构造函数属性（call多个）。</p> <p>4、在子实例中可向父实例传参。</p> <p><code>缺点</code></p> <p>1、只能继承父类构造函数的属性。</p> <p>2、无法实现构造函数的复用。（每次用每次都要重新调用）</p> <p>3、每个新实例都有父类构造函数的副本，臃肿。（构造函数缺点 所有属性都绑定在对应的对象上）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Con</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">&quot;jer&quot;</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">// 调用了 父构造函数 可以传参 提高自由度</span>
    <span class="token comment">// Person2.call(this,&quot;&quot;) 多个构造函数  多继承</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> con1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Con</span><span class="token punctuation">(</span><span class="token string">'rr'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>con1 instanceoof Person<span class="token punctuation">)</span>

</code></pre></div><h5 id="_4-组合继承-组合原型链继承和借用构造函数继承-常用"><a href="#_4-组合继承-组合原型链继承和借用构造函数继承-常用" class="header-anchor">#</a> 4.组合继承（组合原型链继承和借用构造函数继承）（常用）</h5> <p><code>原理</code>  结合了两种模式的优点，传参和复用</p> <p><code>优点</code></p> <p>1、可以继承父类原型上的属性，可以传参，可复用。</p> <p>2、每个新实例引入的构造函数属性是私有的。</p> <p><code>缺点</code>  调用了两次父类构造函数（耗内存），</p> <p>// 子类的构造函数会代替原型上的那个父类构造函数（没有理解）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数继承属性</span>
<span class="token punctuation">}</span>

<span class="token class-name">C</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原型继承方法  new的时候调用第二次 </span>

<span class="token keyword">var</span> per1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

per1<span class="token punctuation">.</span>name<span class="token punctuation">;</span>   <span class="token comment">// 构造函数属性</span>
per1<span class="token punctuation">.</span>age<span class="token punctuation">;</span>  <span class="token comment">// 原型属性</span>

</code></pre></div><h5 id="_5-原型式继承"><a href="#_5-原型式继承" class="header-anchor">#</a> 5.原型式继承</h5> <p><code>原理</code>   先创建了一个<strong>临时性</strong>的构造函数，然后将传入的对象作为个构造函数的原型，最后返回这个构造函数的实例 ，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理 。</p> <p><code>优点</code>类似于复制一个对象，用函数来包装。</p> <p><code>缺点</code></p> <p>1、所有实例都会继承原型上的属性（共享问题）。</p> <p>2、无法实现复用。（新实例属性都是后面添加的）  （不能传参）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">D</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> per4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> per5 <span class="token operator">=</span> <span class="token constant">D</span><span class="token punctuation">(</span>per4<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per5<span class="token punctuation">.</span>name<span class="token punctuation">)</span>


per5 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span> <span class="token comment">//</span>

<span class="token comment">//</span>
<span class="token keyword">new</span> 默认原型对象 create 指定原型对象

Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>是Object的内置方法，可以创建一个新对象，使用现有的对象来提供新创建的对象__proto__

Object<span class="token punctuation">.</span><span class="token function">create</span> <span class="token punctuation">(</span> proto<span class="token punctuation">,</span> <span class="token punctuation">[</span> propertiesObject <span class="token punctuation">]</span> <span class="token punctuation">)</span> 

方法内部定义一个新的空对象obj
将obj<span class="token punctuation">.</span>__proto__的对象指向传入的参数proto
将传入的对象属性复制到obj并且返回obj


</code></pre></div><h5 id="_6-寄生式继承"><a href="#_6-寄生式继承" class="header-anchor">#</a> 6.寄生式继承</h5> <p><code>原理</code>  就是给原型式继承外面套了个壳子。</p> <p><code>优点</code>  传参</p> <p><code>缺点</code>  没用到原型，无法复用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">D</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> per4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token constant">E</span><span class="token punctuation">(</span><span class="token parameter">obj，name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token constant">D</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 继承原型</span>
    sub<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">//在原来的基础上加上私有的东西</span>
    <span class="token keyword">return</span> sub<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> per6 <span class="token operator">=</span> <span class="token constant">E</span><span class="token punctuation">(</span>per4<span class="token punctuation">,</span><span class="token string">'ee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 给原型式继承 加个处理函数传参</span>
</code></pre></div><h5 id="_7-寄生组合式继承-最理想"><a href="#_7-寄生组合式继承-最理想" class="header-anchor">#</a> 7.寄生组合式继承（最理想）</h5> <p><code>原理</code></p> <p>寄生：在函数内返回对象然后调用</p> <p>组合：1、函数的原型等于另一个实例。</p> <p>​			2、在函数中用apply或者call引入另一个构造函数，可传参</p> <p><code>优点</code>  修复了组合继承的问题</p> <p><code>缺点</code>	过于繁琐，故不如组合继承</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 寄生</span>
<span class="token keyword">function</span> <span class="token constant">G</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// G 是 F实例的另一种表示</span>
<span class="token keyword">var</span> g1 <span class="token operator">=</span> <span class="token constant">G</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//组合</span>
<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//重点</span>
<span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> g1<span class="token punctuation">;</span>  <span class="token comment">//继承 实例</span>
g1<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub<span class="token punctuation">;</span> <span class="token comment">// 修复 实例</span>
<span class="token keyword">var</span> sub1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//sub1 就继承了继承 函数属性，父类实例，g1 的函数属性 </span>

sub1<span class="token punctuation">.</span>age<span class="token punctuation">;</span>

</code></pre></div><h5 id="_8-es6继承-class-extends"><a href="#_8-es6继承-class-extends" class="header-anchor">#</a> 8.ES6继承 （class）（extends）</h5> <p><code>原理</code>Class之间通过使用extends关键字，这比通过修改原型链实现继承，要方便清晰很多</p> <p>新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p> <div class="language-js extra-class"><pre class="language-js"><code>相当于构造函数的另一种写法
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Colorpoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token comment">//这个就是默认方法  使用new 生成实例时  会调用这个方法，</span>
    <span class="token comment">//如果未定义 会自动添加 </span>
    
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        
        <span class="token comment">//子类必须在constructor方法中调用super方法，否则新建实例时会报错</span>
        <span class="token comment">//这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象。</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用父类构造函数(Point.prototype.constructor.call(this,x,y))</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
        
        <span class="token comment">// 隐式返回 this</span>
        <span class="token comment">// 如果显示返回对象 就是该对象</span>
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//通过 super调用父类的方法</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token constant">A</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token constant">B</span><span class="token punctuation">;</span>  <span class="token comment">//继承属性</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> <span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment">//继承方法</span>

<span class="token function">typeOf</span><span class="token punctuation">(</span>Colorpoint<span class="token punctuation">)</span>
<span class="token comment">//类的数据类型就是函数，类本身就指向构造函数。</span>
<span class="token comment">//类的所有方法都定义在类的prototype属性上面。</span>
<span class="token class-name">Colorpoint</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Colorpoint <span class="token comment">// true</span>

Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Colorpoint</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

与 es5 不同之处

<span class="token number">1.</span> toString方法是Colorpoint类内部定义的方法，它是不可枚举的。这一点与 <span class="token constant">ES5</span> 的行为不一致。
<span class="token number">2.</span> 必须使用<span class="token keyword">new</span> 调用
<span class="token number">3.</span>不存在变量提升，必须先声明在使用

与es5 相同之处
<span class="token number">1</span><span class="token punctuation">.</span>prototype对象的constructor属性，直接指向“类”的本身
<span class="token number">2.</span> 与 <span class="token constant">ES5</span> 一样，实例的属性除非显式定义在其本身（即定义在<span class="token keyword">this</span>对象上），否则都是定义在原型上（即定义在<span class="token keyword">class</span>上）。
<span class="token number">3.</span>类的所有实例共享一个原型对象。

Colorpoint<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
Colorpoint<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
Colorpoint<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>


</code></pre></div><p>“extends” 语法会设置两个原型：</p> <ol><li>在构造函数的 <code>&quot;prototype&quot;</code> 之间设置原型（为了获取实例方法）</li> <li>在构造函数之间会设置原型（为了获取静态方法）</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//继承对象</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span>   和   <span class="token keyword">class</span> <span class="token class-name">A</span> 区别
继承自对象				       继承自函数
构造函数中需要调用父类构造函数 
</code></pre></div><p><code>super</code></p> <ol><li><p>作为函数使用  <code>调用父类构造函数</code></p></li> <li><p>作为对象使用 <code>静态时指向父类本身可以调用父类本身的属性和方法</code>·<code>指向父类的原型</code></p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//动态时由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  调用父类函数时 会绑定子类的this</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span>m <span class="token comment">// undefined</span>

<span class="token comment">// 用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'static'</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance'</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Child<span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// static 1</span>

<span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
child<span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// instance 2</span>

<span class="token comment">//在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token constant">B</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token constant">B</span><span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>

</code></pre></div><ol start="3"><li>所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined  A.prototype.x</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><ol start="4"><li>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</li> <li>直接打印 super会报错 由于浏览器不知道是函数还是对象， 所以必须显式指定是作为函数、还是作为对象使用</li> <li><strong>箭头函数没有</strong> <code>super</code></li> <li><code>[[HomeObject]]</code>   super 的特殊特征</li></ol> <p>参考：</p> <p>https://juejin.im/post/5d3551fcf265da1ba4322b20#heading-0</p> <p><a href="https://www.cnblogs.com/Grace-zyy/p/8206002.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Grace-zyy/p/8206002.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.cnblogs.com/loveyaxin/p/11151586.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/loveyaxin/p/11151586.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://segmentfault.com/a/1190000015642813" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000015642813<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>https://zh.javascript.info/class-inheritance</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/notes/基础知识扩展/对象迭代的方法.html">
        对象迭代的方法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.c0270f27.js" defer></script><script src="/notes/assets/js/2.c60e90e7.js" defer></script><script src="/notes/assets/js/27.6d5b0d55.js" defer></script>
  </body>
</html>
