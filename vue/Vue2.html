<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基础 | yh的学习文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/notes/assets/css/0.styles.aa6162e3.css" as="style"><link rel="preload" href="/notes/assets/js/app.856fc53b.js" as="script"><link rel="preload" href="/notes/assets/js/2.c60e90e7.js" as="script"><link rel="preload" href="/notes/assets/js/20.6e69c898.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.3058cf05.js"><link rel="prefetch" href="/notes/assets/js/11.b8a79bac.js"><link rel="prefetch" href="/notes/assets/js/12.3550f838.js"><link rel="prefetch" href="/notes/assets/js/13.086d0aa7.js"><link rel="prefetch" href="/notes/assets/js/14.61a3f64f.js"><link rel="prefetch" href="/notes/assets/js/15.af4f2e97.js"><link rel="prefetch" href="/notes/assets/js/16.0ac57349.js"><link rel="prefetch" href="/notes/assets/js/17.31326e7e.js"><link rel="prefetch" href="/notes/assets/js/18.209484df.js"><link rel="prefetch" href="/notes/assets/js/19.f64d0f09.js"><link rel="prefetch" href="/notes/assets/js/21.7be772d6.js"><link rel="prefetch" href="/notes/assets/js/22.5dfd15e0.js"><link rel="prefetch" href="/notes/assets/js/23.232da89e.js"><link rel="prefetch" href="/notes/assets/js/24.bc5bd2c1.js"><link rel="prefetch" href="/notes/assets/js/25.a631bd07.js"><link rel="prefetch" href="/notes/assets/js/26.69d69206.js"><link rel="prefetch" href="/notes/assets/js/27.b32c47dd.js"><link rel="prefetch" href="/notes/assets/js/28.d4309a3f.js"><link rel="prefetch" href="/notes/assets/js/29.a3dd8f13.js"><link rel="prefetch" href="/notes/assets/js/3.fb28e9ff.js"><link rel="prefetch" href="/notes/assets/js/30.1b1de285.js"><link rel="prefetch" href="/notes/assets/js/31.0125f057.js"><link rel="prefetch" href="/notes/assets/js/32.5f5833f4.js"><link rel="prefetch" href="/notes/assets/js/33.33ec2536.js"><link rel="prefetch" href="/notes/assets/js/34.eda8d19b.js"><link rel="prefetch" href="/notes/assets/js/35.92d3a36a.js"><link rel="prefetch" href="/notes/assets/js/36.6c6335dd.js"><link rel="prefetch" href="/notes/assets/js/37.f0fe8a72.js"><link rel="prefetch" href="/notes/assets/js/38.03e7fbf7.js"><link rel="prefetch" href="/notes/assets/js/39.d4db5a29.js"><link rel="prefetch" href="/notes/assets/js/4.b7d0708f.js"><link rel="prefetch" href="/notes/assets/js/40.a698d443.js"><link rel="prefetch" href="/notes/assets/js/41.4e605a7c.js"><link rel="prefetch" href="/notes/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/notes/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/notes/assets/js/7.e7497572.js"><link rel="prefetch" href="/notes/assets/js/8.65f2487c.js"><link rel="prefetch" href="/notes/assets/js/9.1de6ed85.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.aa6162e3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">yh的学习文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础知识扩展</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>http</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/vue/Vue2.html" aria-current="page" class="active sidebar-link">Vue2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#基础" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#vue对象选项" class="sidebar-link">vue对象选项</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#指令" class="sidebar-link">指令</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#插槽" class="sidebar-link">插槽</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#混入-mixin" class="sidebar-link">混入 mixin</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#过滤器" class="sidebar-link">过滤器</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#组件" class="sidebar-link">组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#动态组件" class="sidebar-link">动态组件</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#单文件组件" class="sidebar-link">单文件组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#路由" class="sidebar-link">路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#关键组件" class="sidebar-link">关键组件</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#router-config" class="sidebar-link">router config</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#实例方法" class="sidebar-link">实例方法</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#路由懒加载" class="sidebar-link">路由懒加载</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#过渡效果" class="sidebar-link">过渡效果</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#滚动行为" class="sidebar-link">滚动行为</a></li></ul></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#diff算法" class="sidebar-link">diff算法</a></li><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#vue2-7" class="sidebar-link">vue2.7</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/vue/Vue2.html#版本升级" class="sidebar-link">版本升级</a></li></ul></li></ul></li><li><a href="/notes/vue/Vue的一些高级用法.html" class="sidebar-link">Vue2的一些高级用法</a></li><li><a href="/notes/vue/Vue3.html" class="sidebar-link">Vue3</a></li><li><a href="/notes/vue/Vue-store.html" class="sidebar-link">Vue-store</a></li><li><a href="/notes/vue/Vue-Router.html" class="sidebar-link">vue-router</a></li><li><a href="/notes/vue/组件库搭建.html" class="sidebar-link">menorepo</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/notes/typescript/ts.html" class="sidebar-link">typescript</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具类</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="vue对象选项"><a href="#vue对象选项" class="header-anchor">#</a> vue对象选项</h3> <div class="language- extra-class"><pre class="language-text"><code>let vm = new Vue({
	// DOM
	el:  '#root',
	template: &lt;div&gt;&lt;/div&gt;,
	render: () =&gt; {},
	renderError: () =&gt; {},
	// 数据
	data: {},
	props: {},
	methods:{},
	computed:{},
	watch: {}
	// 生命周期钩子
	beforeCreate:()=&gt;{},
	created:()=&gt;{},
	beforeMount:()=&gt;{},
	mounted:()=&gt;{},
	beforeUpdate:()=&gt;{},
	updated:()=&gt;{},
	beforeDestory:()=&gt;{},
	destoryed:()=&gt;{},
	activated:()=&gt;{},
	deactivated:()=&gt;{},
	errorCaptured:()=&gt;{},
	// 资源
	directives: {},
	filters: {},
	components:{},
	// 其他
	name: 'vm',
})
</code></pre></div><h4 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h4> <h5 id="el"><a href="#el" class="header-anchor">#</a> el</h5> <blockquote><p>如果 <code>render</code> 函数和 <code>template</code> property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板</p></blockquote> <ul><li><p>类型：string | Element</p></li> <li><p>限制：只在用new Vue创建实例时生效</p></li> <li><p>详细：</p> <p>实例挂载点</p></li></ul> <h5 id="template"><a href="#template" class="header-anchor">#</a> template</h5> <blockquote><p>如果 Vue 选项中包含<code>render</code>函数，该模板将被忽略。</p></blockquote> <ul><li><p>类型：string</p></li> <li><p>详细：</p> <p>替换挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p></li></ul> <h5 id="render"><a href="#render" class="header-anchor">#</a> render</h5> <ul><li>类型：(createElement: () =&gt; VNode) =&gt; VNode</li></ul> <h5 id="rendererror"><a href="#rendererror" class="header-anchor">#</a> renderError</h5> <blockquote><p>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。</p></blockquote> <ul><li>类型：(createElement: () =&gt; VNode,error: Error) =&gt; VNode</li></ul> <h4 id="数据"><a href="#数据" class="header-anchor">#</a> 数据</h4> <h5 id="data"><a href="#data" class="header-anchor">#</a> data</h5> <ul><li>类型：Object | Function</li> <li>限制：组件的定义只接受Function</li></ul> <h5 id="props"><a href="#props" class="header-anchor">#</a> props</h5> <ul><li><p>类型：<code>Array&lt;string&gt;</code> | Object</p></li> <li><p>详细：props是对象时，可以检查prop类型</p> <p>你可以基于对象的语法使用以下选项：</p> <ul><li><code>type</code>：可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。</li> <li><code>default</code>：<code>any</code></li> <li><code>required</code>：<code>Boolean</code></li> <li><code>validator</code>：<code>Function</code>
自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。</li></ul></li></ul> <h5 id="propsdata"><a href="#propsdata" class="header-anchor">#</a> propsData</h5> <blockquote><p>没用过没见过，先空着吧</p></blockquote> <h5 id="computed"><a href="#computed" class="header-anchor">#</a> computed</h5> <blockquote><p>计算属性，一般用于多个数据影响一个数据。</p> <p>计算属性的结果会被缓存，如果依赖数据不变，再次调用时不会重新计算。</p> <p>计算属性的用法和data一样</p></blockquote> <ul><li>类型：{ [key:string]: Fcuntion | { get : Function, set: Function } }</li></ul> <h5 id="methods"><a href="#methods" class="header-anchor">#</a> methods</h5> <blockquote><p>方法，需要手动调用</p> <p>每次调用都会重新计算</p></blockquote> <ul><li>类型：{ [key: string]: Function }</li></ul> <h5 id="watch"><a href="#watch" class="header-anchor">#</a> watch</h5> <blockquote><p>监测，一般用于一个数据影响多个数据</p> <p>依赖数据变化时自动调用</p></blockquote> <ul><li>类型：{ [key: string]: string | Function | Object | Array }  Function 应该是最常用的</li></ul> <h4 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h4> <h5 id="一般钩子"><a href="#一般钩子" class="header-anchor">#</a> 一般钩子</h5> <p><img src="/notes/imgs/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="vue生命周期"></p> <h5 id="activated-deactivated"><a href="#activated-deactivated" class="header-anchor">#</a> activated/deactivated</h5> <blockquote><p>被 keep-alive 缓存的组件激活/停用时调用。</p></blockquote> <h5 id="errorcaptured"><a href="#errorcaptured" class="header-anchor">#</a> errorCaptured</h5> <blockquote><p>当捕获一个来自子孙组件的错误时被调用。2.5.0+ 新增</p></blockquote> <ul><li>类型：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></li></ul> <h4 id="资源"><a href="#资源" class="header-anchor">#</a> 资源</h4> <h5 id="components"><a href="#components" class="header-anchor">#</a> components</h5> <blockquote><p>定义Vue实例可用组件</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import ComponentA from 'xxx'
new Vue({
  ...
  components: {
  	'component-a': ComponentA
  }
})
</code></pre></div><h5 id="directives"><a href="#directives" class="header-anchor">#</a> directives</h5> <p><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4">自定义指令</a></p> <blockquote><p>定义Vue实例可用指令</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  ...
  directives: {
    focus: {
      // 指令的定义
      inserted: function (el) {
        el.focus()
      }
    }
  }
})
</code></pre></div><h5 id="filters"><a href="#filters" class="header-anchor">#</a> filters</h5> <p><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8">过滤器</a></p> <blockquote><p>定义Vue实例可用过滤器</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  ...
  filters: {
  	capitalize: function (value) {
  		...
  		return ....
  	}
  }
})
</code></pre></div><h4 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h4> <h5 id="mixins"><a href="#mixins" class="header-anchor">#</a> mixins</h5> <p>[混入](#混入 mixin)</p> <blockquote><p><code>mixins</code> 选项接收一个混入对象的数组。</p></blockquote> <ul><li>类型：<code>Array&lt;Object&gt;</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>var mixin = {
  created: function () { console.log(1) }
}
var vm = new Vue({
  created: function () { console.log(2) },
  mixins: [mixin]
})
</code></pre></div><h5 id="name"><a href="#name" class="header-anchor">#</a> name</h5> <ul><li>类型：string</li> <li>限制：只有作为组件选项时起作用</li></ul> <h3 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h3> <h4 id="常用指令"><a href="#常用指令" class="header-anchor">#</a> 常用指令</h4> <ul><li><p>v-text</p></li> <li><p>v-html</p></li> <li><p>v-show</p></li> <li><p>v-if</p></li> <li><p>v-else-if</p></li> <li><p>v-else</p></li> <li><p>v-for</p> <p>必须有唯一的key值，如果数据有插入/删除等影响原有数据顺序的情况，不建议使用index作为key值。</p></li> <li><p>v-on</p> <p>绑定事件</p> <p>可以简写为@click的形式</p></li> <li><p>v-bind</p> <p>动态属性</p> <p>可以简写为:title的形式</p></li> <li><p>v-model</p> <p>双向绑定</p> <p>:value 和 @input 的语法糖</p></li> <li><p>v-slot</p> <p><a href="#%E6%8F%92%E6%A7%BD">插槽</a></p> <p>v-slot: 插槽名，默认为default</p> <p>可以简写为#header</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 具名插槽 --&gt;
&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    Header content
  &lt;/template&gt;

  Default slot content

  &lt;template v-slot:footer&gt;
    Footer content
  &lt;/template&gt;
&lt;/base-layout&gt;

&lt;!-- 接收 prop 的具名插槽 --&gt;
&lt;infinite-scroll&gt;
  &lt;template v-slot:item=&quot;slotProps&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;
      {{ slotProps.item.text }}
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/infinite-scroll&gt;

&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;
&lt;mouse-position v-slot=&quot;{ x, y }&quot;&gt;
  Mouse position: {{ x }}, {{ y }}
&lt;/mouse-position&gt;
</code></pre></div></li> <li><p>v-pre</p> <p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p></li> <li><p>v-cloak</p> <p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p></li> <li><p>v-once</p> <p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p> <p><strong>如果确定这个元素及其子组件以后再也不会变动时使用</strong></p></li></ul> <h4 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h4> <h5 id="钩子函数"><a href="#钩子函数" class="header-anchor">#</a> 钩子函数</h5> <ul><li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p></li> <li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p></li> <li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</p></li> <li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p></li> <li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p></li></ul> <h5 id="参数说明"><a href="#参数说明" class="header-anchor">#</a> 参数说明</h5> <ul><li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li> <li><code>binding</code>：一个对象，包含以下 property：
<ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li> <li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li> <li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li> <li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li> <li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li> <li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li></ul></li> <li><code>vnode</code>：Vue 编译生成的虚拟节点。</li> <li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul> <blockquote><p>除了 <code>el</code> 之外，其它参数都应该是只读的。</p></blockquote> <h3 id="插槽"><a href="#插槽" class="header-anchor">#</a> 插槽</h3> <h4 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h4> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;Child&gt;父组件传值&lt;/Child&gt;
&lt;Child&gt;&lt;/Child&gt;
// Child子组件
&lt;div&gt;
	子组件内容...
	&lt;slot&gt;默认内容&lt;/slot&gt;
&lt;/div&gt;

// 最终显示1
	子组件内容...
	父组件传值
// 最终显示2
	子组件内容...
	默认内容
</code></pre></div><h4 id="具名插槽"><a href="#具名插槽" class="header-anchor">#</a> 具名插槽</h4> <blockquote><p>用于组件内有多处插槽时，确定内容插入位置</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;

// 子组件
&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre></div><h4 id="作用域插槽"><a href="#作用域插槽" class="header-anchor">#</a> 作用域插槽</h4> <div class="language- extra-class"><pre class="language-text"><code>// 父组件获取子组件绑定的属性
// v-slot:default=&quot;slotProps&quot;  可以简写为   v-slot=&quot;slotProps&quot;  只有default插槽可以这么简写
&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    {{ slotProps.user.firstName }}
  &lt;/template&gt;
  &lt;template v-slot:deconstruction=&quot;{user={firstName: 'hh'}}&quot;&gt;
    {{ user.firstName }}
  &lt;/template&gt;
&lt;/current-user&gt;

// 子组件绑定user属性
&lt;span&gt;
  &lt;slot :user=&quot;user&quot;&gt;
    {{ user.lastName }}
  &lt;/slot&gt;
  &lt;slot :user=&quot;user&quot; name='deconstruction'&gt;
    解构插槽Prop
    这里可以用到ES6解构的所有语法，比如重命名、默认赋值
  &lt;/slot&gt;
&lt;/span&gt;
</code></pre></div><h4 id="缩写"><a href="#缩写" class="header-anchor">#</a> 缩写</h4> <p><code>v-slot:header=&quot;{user}&quot;</code></p> <p>简写为</p> <p><code>#header=&quot;{user}&quot;</code></p> <p><strong>default可以省略</strong></p> <p><code>v-slot=&quot;{user}&quot;</code></p> <p>简写为</p> <p><code>#=&quot;{user}&quot;</code></p> <h4 id="废弃的用法"><a href="#废弃的用法" class="header-anchor">#</a> 废弃的用法</h4> <p><strong><code>slot</code> 和 <code>slot-scope</code></strong></p> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;div slot='header' slot-scope=&quot;slotProps&quot;&gt;&lt;/div&gt;
</code></pre></div><h3 id="混入-mixin"><a href="#混入-mixin" class="header-anchor">#</a> 混入 mixin</h3> <blockquote><p>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p></blockquote> <h4 id="合并方式"><a href="#合并方式" class="header-anchor">#</a> 合并方式</h4> <ul><li>数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先</li> <li>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对</li> <li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用</li></ul> <h3 id="过滤器"><a href="#过滤器" class="header-anchor">#</a> 过滤器</h3> <h4 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h4> <ul><li>在组件内定义</li></ul> <div class="language- extra-class"><pre class="language-text"><code>filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
</code></pre></div><ul><li>全局注册</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})
</code></pre></div><h4 id="使用-2"><a href="#使用-2" class="header-anchor">#</a> 使用</h4> <ul><li>过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 在双花括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre></div><ul><li>串联</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{{ message | filterA | filterB }}
</code></pre></div><ul><li>接收参数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{{ message | filterA('arg1', arg2) }}
</code></pre></div><h2 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h2> <h3 id="动态组件"><a href="#动态组件" class="header-anchor">#</a> 动态组件</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;
&lt;component :is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
</code></pre></div><h4 id="keep-alive"><a href="#keep-alive" class="header-anchor">#</a> keep-alive</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;keep-alive&gt;
  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre></div><p><strong>遇到的问题：不需要缓存的组件也被缓存</strong></p> <p>解决方案：<code>include</code> 和 <code>exclude</code></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;keep-alive exclude=&quot;Detail&quot;&gt;
  &lt;component :is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre></div><h3 id="单文件组件"><a href="#单文件组件" class="header-anchor">#</a> 单文件组件</h3> <blockquote><p>文件扩展名为 .vue 的 single-file components (单文件组件)</p></blockquote> <ul><li><p>包起来，只能有一个根元素</p></li> <li><p>导出组件内容</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
	module.exports = {
		name: 'componentA',
		data: function() {
			return {}
		}
		// 其他配置
		...
	}
&lt;/script&gt;
</code></pre></div></li> <li><p>样式</p> <p><code>scoped</code>的作用是：使style中定义的样式只在当前组件中生效，避免污染全局样式</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style scoped&gt;
&lt;/style&gt;
</code></pre></div></li></ul> <h2 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h2> <h3 id="关键组件"><a href="#关键组件" class="header-anchor">#</a> 关键组件</h3> <h5 id="router-link"><a href="#router-link" class="header-anchor">#</a> router-link</h5> <blockquote><p><code>router-link</code> 组件支持用户在具有路由功能的应用中 (点击) 导航。</p> <p>通过 <code>to</code> 属性指定目标地址，默认渲染成带有正确链接的 <code>a</code> 标签，可以通过配置 <code>tag</code> 属性生成别的标签.。</p> <p>另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</p></blockquote> <h5 id="to"><a href="#to" class="header-anchor">#</a> to</h5> <ul><li><p>类型：<code>string | Location</code></p></li> <li><p>required</p> <blockquote><p>表示目标路由的链接。当被点击后，内部会立刻把 <code>to</code> 的值传到 <code>router.push()</code>，所以这个值可以是一个字符串或者是描述目标位置的对象。</p></blockquote></li></ul> <h5 id="replace"><a href="#replace" class="header-anchor">#</a> replace</h5> <ul><li><p>类型: <code>boolean</code></p></li> <li><p>默认值: <code>false</code></p> <blockquote><p>设置 <code>replace</code> 属性的话，当点击时，会调用 <code>router.replace()</code> 而不是 <code>router.push()</code>，于是导航后不会留下 history 记录。</p></blockquote></li></ul> <h5 id="append"><a href="#append" class="header-anchor">#</a> append</h5> <ul><li><p>类型: <code>boolean</code></p></li> <li><p>默认值: <code>false</code></p> <blockquote><p>设置 <code>append</code> 属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 <code>/a</code> 导航到一个相对路径 <code>b</code>，如果没有配置 <code>append</code>，则路径为 <code>/b</code>，如果配了，则为 <code>/a/b</code></p> <p>用到嵌套路由中，就不需要写多层path</p></blockquote></li></ul> <h5 id="tag"><a href="#tag" class="header-anchor">#</a> tag</h5> <ul><li><p>类型: <code>string</code></p></li> <li><p>默认值: <code>&quot;a&quot;</code></p> <p>有时候想要 <code>router-link</code> 渲染成某种标签，例如 <code>li</code>。 于是我们使用 <code>tag</code> prop 类指定何种标签，同样它还是会监听点击，触发导航。</p></li></ul> <h5 id="active-class"><a href="#active-class" class="header-anchor">#</a> active-class</h5> <ul><li><p>类型: <code>string</code></p></li> <li><p>默认值: <code>&quot;router-link-active&quot;</code></p> <blockquote><p>设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 <code>linkActiveClass</code> 来全局配置。</p></blockquote></li></ul> <h5 id="exact"><a href="#exact" class="header-anchor">#</a> exact</h5> <blockquote><ul><li><p>类型: <code>boolean</code></p></li> <li><p>默认值: <code>false</code></p> <p>“是否激活”默认类名的依据是<strong>包含匹配</strong>。 举个例子，如果当前的路径是 <code>/a</code> 开头的，那么 <code>&lt;router-link to=&quot;/a&quot;&gt;</code> 也会被设置 CSS 类名。</p> <p>按照这个规则，每个路由都会激活 <code>&lt;router-link to=&quot;/&quot;&gt;</code>！想要链接使用“精确匹配模式”，则使用 <code>exact</code> 属性</p></li></ul></blockquote> <h4 id="router-view"><a href="#router-view" class="header-anchor">#</a> router-view</h4> <blockquote><p><code>router-view</code>组件是一个 functional 组件，渲染路径匹配到的视图组件。<code>router-view</code> 渲染的组件还可以内嵌自己的<code>router-view</code> ，根据嵌套路径，渲染嵌套组件。</p></blockquote> <h5 id="name-2"><a href="#name-2" class="header-anchor">#</a> name</h5> <blockquote><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code></p></blockquote> <ul><li><p>类型: <code>string</code></p></li> <li><p>默认值: <code>&quot;default&quot;</code></p> <blockquote><p>如果 <code>router-view</code>设置了名称，则会渲染对应的路由配置中 <code>components</code> 下的相应组件</p></blockquote></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;

// config
const router = new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        default: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
})
</code></pre></div><h3 id="router-config"><a href="#router-config" class="header-anchor">#</a> router config</h3> <h4 id="routes"><a href="#routes" class="header-anchor">#</a> routes</h4> <div class="language- extra-class"><pre class="language-text"><code>interface RouteConfig = {
  path: string,   // 路由路径
  component?: Component,  //  该路由对应展示的组件
  name?: string, // 命名路由
  components?: { [name: string]: Component }, // 命名视图组件
  redirect?: string | Location | Function,  //  进入该路由时重定向到其他路径
  props?: boolean | Object | Function,
  alias?: string | Array&lt;string&gt;, // 别名：当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。
  children?: Array&lt;RouteConfig&gt;, // 嵌套路由
  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void,
  meta?: any,
  caseSensitive?: boolean, // 匹配规则是否大小写敏感？(默认值：false)
  pathToRegexpOptions?: Object // 编译正则的选项
}
</code></pre></div><h4 id="mode"><a href="#mode" class="header-anchor">#</a> mode</h4> <ul><li>类型: <code>string</code></li> <li>默认值: <code>&quot;hash&quot; (浏览器环境) | &quot;abstract&quot; (Node.js 环境)</code></li> <li>可选值: <code>&quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;</code></li></ul> <h4 id="base"><a href="#base" class="header-anchor">#</a> base</h4> <ul><li><p>类型: <code>string</code></p></li> <li><p>默认值: <code>&quot;/&quot;</code></p> <p>应用的基路径。例如，如果整个单页应用服务在 <code>/app/</code> 下，然后 <code>base</code> 就应该设为 <code>&quot;/app/&quot;</code></p></li></ul> <h4 id="linkactiveclass"><a href="#linkactiveclass" class="header-anchor">#</a> linkActiveClass</h4> <ul><li><p>类型: <code>string</code></p></li> <li><p>默认值: <code>&quot;router-link-active&quot;</code></p> <p>全局配置 <code>router-link</code> 默认的激活的 class。</p></li></ul> <h4 id="scrollbehavior"><a href="#scrollbehavior" class="header-anchor">#</a> scrollBehavior</h4> <p><a href="#%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA">滚动行为</a></p> <ul><li>类型: `Function</li></ul> <h4 id="fallback"><a href="#fallback" class="header-anchor">#</a> fallback</h4> <ul><li><p>类型: <code>boolean</code></p></li> <li><p>默认值: <code>true</code></p> <p>当浏览器不支持 <code>history.pushState</code> 控制路由是否应该回退到 <code>hash</code> 模式。默认值为 <code>true</code>。</p></li></ul> <h3 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h3> <h4 id="编程式导航"><a href="#编程式导航" class="header-anchor">#</a> 编程式导航</h4> <ul><li><code>router.push(path)</code>: 跳转到某个路径</li> <li><code>router.replace(path)</code>:不产生新的历史记录</li> <li><code>router.go(num)</code>:向前进num个路径，如果是负数，就返回num个记录</li> <li><code>router.back()</code>:返回上一个记录</li> <li><code>router.forward()</code>:向前进一个记录</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 字符串
router.push('home')

// 对象
router.push({ path: 'home' })

// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})

// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})
</code></pre></div><h4 id="导航守卫"><a href="#导航守卫" class="header-anchor">#</a> 导航守卫</h4> <h4 id="其他-2"><a href="#其他-2" class="header-anchor">#</a> 其他</h4> <h3 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h3> <h3 id="过渡效果"><a href="#过渡效果" class="header-anchor">#</a> 过渡效果</h3> <h3 id="滚动行为"><a href="#滚动行为" class="header-anchor">#</a> 滚动行为</h3> <h2 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 判断DOM元素是否相同的方法</span>
<span class="token keyword">function</span> <span class="token function">sameVnode</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    a<span class="token punctuation">.</span>key <span class="token operator">===</span> b<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span>
    a<span class="token punctuation">.</span>asyncFactory <span class="token operator">===</span> b<span class="token punctuation">.</span>asyncFactory <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
      <span class="token punctuation">(</span>
        a<span class="token punctuation">.</span>tag <span class="token operator">===</span> b<span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span>
        a<span class="token punctuation">.</span>isComment <span class="token operator">===</span> b<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span>
        <span class="token function">isDef</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">sameInputType</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>
        <span class="token function">isTrue</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>isAsyncPlaceholder<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">isUndef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>asyncFactory<span class="token punctuation">.</span>error<span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>判断元素是否相同，直接循环遍历，进行patch操作</p></li> <li><p>元素相同，对比属性、对比子节点</p> <ul><li><p>子节点为文本，直接修改</p></li> <li><p>无key，直接循环遍历，进行patch操作</p></li> <li><p>有key，<em>深度递归+双指针</em>（以下比较都是用key进行，如果有相同的则进行 patch 操作）</p> <p>『头头 — 尾尾 — 头尾— 尾头』</p> <ol><li><p>比较 oldStart 和 newStart 的节点，如果一样，则 oldStart++ 、 newStart++｝</p> <p><img src="/notes/imgs/vue/vue2-diff-1.png" alt="vue2-diff-1"></p></li> <li><p>比较 oldEnd 和 newEnd 的节点，如果一样，则 oldEnd-- 、 newEnd--</p> <p><img src="/notes/imgs/vue/vue2-diff-2.png" alt="vue2-diff-2"></p></li> <li><p>1&amp;2 不满足的情况下，比较 oldStart 和 newEnd 的节点，如果一样，将 oldStart 对应的<strong>真实DOM</strong>移动到 oldEnd 对应的<strong>真实DOM</strong>之后，oldStart ++、newEnd--</p> <p><img src="/notes/imgs/vue/vue2-diff-3.png" alt="vue2-diff-3"></p></li> <li><p>1&amp;2&amp;3不满足的情况下，比较 oldEnd 和 newStart 的节点，如果一样，将 oldEnd 对应的<strong>真实DOM</strong>移动到 oldStart 对应的<strong>真实DOM</strong>之前，newStart++、oldEnd--</p> <p><img src="/notes/imgs/vue/vue2-diff-4.png" alt="vue2-diff-4"></p></li> <li><p>均不满足的情况下，循环比较 newStart对应节点 和 所有旧节点</p> <ul><li><p>如果有key，寻找key值相同的节点，将对应的<strong>真实DOM</strong>移动到 oldStart 对应的<strong>真实DOM</strong>之前，oldStart++ 、newStart++</p> <p><img src="/notes/imgs/vue/vue2-diff-5-1.png" alt="vue2-diff-5-1"></p></li> <li><p>没有找到相同的节点，在 oldStart 之前创建新的DOM，oldStart++ 、 newStart++</p> <p><img src="/notes/imgs/vue/vue2-diff-5-2.png" alt="vue2-diff-5-2"></p></li></ul></li> <li><p>旧节点中未遍历完的节点，在oldStart和 oldEnd 之间的节点是需要删除的</p> <p>新节点中未遍历完的节点，在newStart 和 newEnd 之间的节点是需要新增的，新增在 newEnd 后一个节点之前</p></li></ol></li></ul></li></ul> <h2 id="vue2-7"><a href="#vue2-7" class="header-anchor">#</a> vue2.7</h2> <blockquote><p>支持你的项目在不升级Vue3的情况下使用Vue3的特性，例如Composition Api、setup、Css v-bind等</p></blockquote> <h3 id="版本升级"><a href="#版本升级" class="header-anchor">#</a> 版本升级</h3> <h4 id="vue-cli"><a href="#vue-cli" class="header-anchor">#</a> vue-cli</h4> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// &quot;@vue/cli-plugin-babel&quot;: &quot;^4.0.0&quot;,</span>
      <span class="token comment">// &quot;@vue/cli-plugin-eslint&quot;: &quot;^4.0.0&quot;,</span>
      <span class="token comment">// &quot;@vue/cli-service&quot;: &quot;^4.0.0&quot;,</span>
      <span class="token comment">// 修改为</span>
      <span class="token property">&quot;@vue/cli-plugin-babel&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.5.18&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;@vue/cli-plugin-eslint&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.5.18&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;@vue/cli-service&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.5.18&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="vue"><a href="#vue" class="header-anchor">#</a> vue</h4> <div class="language-json extra-class"><pre class="language-json"><code>
<span class="token punctuation">{</span>
  <span class="token property">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// &quot;vue&quot;: &quot;2.6.14&quot;,</span>
      <span class="token comment">// 修改为</span>
      <span class="token property">&quot;vue&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2.7.0&quot;</span><span class="token punctuation">,</span>
      <span class="token comment">// vue2.7 不再需要vue-template-compoler，所以可以将其删除</span>
      <span class="token comment">// &quot;vue-template-compiler&quot;: &quot;2.6.14&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="vue-composition-api"><a href="#vue-composition-api" class="header-anchor">#</a> @vue/composition-api</h4> <p>如果之前已经在Vue2的项目使用上了@vue/composition-api，这时你需要将项目中所用到的导入更新为vue:</p> <div class="language-vue extra-class"><pre class="language-vue"><code>// import { ref } from '@vue/composition-api'
import { ref } from 'vue'
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/http/https.html" class="prev">
        https
      </a></span> <span class="next"><a href="/notes/vue/Vue的一些高级用法.html">
        Vue2的一些高级用法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.856fc53b.js" defer></script><script src="/notes/assets/js/2.c60e90e7.js" defer></script><script src="/notes/assets/js/20.6e69c898.js" defer></script>
  </body>
</html>
