# 数组

## 生成数组

```js
// 方案1
const createArr = (n) => Array.from(new Array(n), (v, i) => i)
const arr = createArr(100) // 0 - 99 数组

// 方案2
const createArr = (n) => new Array(n).fill(0).map((v, i) => i)
createArr(100) // 0 - 99数组
```

## 打乱数组

```js
const randomSort = list => list.sort(() => Math.random() - 0.5)
randomSort([0,1,2,3,4,5,6,7,8,9]) // 随机排列结果
```

## 数组去重

```js
const removeDuplicates = list => [...new Set(list)]
removeDuplicates([0, 0, 2, 4, 5]) // [0, 2, 4, 5]
```

### 多数组取交集

```js
const intersection = (a, ...arr) => [...new Set(a)].filter((v) => arr.every((b) => b.includes(v)))
intersection([1, 2, 3, 4], [2, 3, 4, 7, 8], [1, 3, 4, 9]) // [3, 4]
```

## 查找最大/最小值索引

```js
const indexOfMax = arr = arr.reduce((prev, curr, index, a) => (curr > a[prev] ? index : prev), 0)
const indexOfMin = arr = arr.reduce((prev, curr, index, a) => (curr < a[prev] ? index : prev), 0)
```

## 找到最接近的数值

```js
const closest = (arr, n) => arr.reduce((prev, curr, index, a) => (Math.abs(prev - n) > Math.abs(curr - n) ? curr : prev))
closest([29, 87, 8, 78, 97, 20, 75, 33, 24, 17], 50) // 33
```

## 矩阵交换行和列

```js
const transpose = matrix => matrix[0].map((col, colIndex) => matrix.map((row) => row[colIndex]));
// 将第colIndex行的值改为原数组第colIndex列的所有值组成的数组
```

## 多个数组转为索引相同的二维数组

```js
const zip = (...arr) => Array.from({ length: Math.max(...arr.map((a) => a.length)) }, (_, i) => arr.map((a) => a[i]))
zip([1,2,3,4], ['a', 'b', 'c', 'd'], ['A', 'B', 'C', 'D']) // [[1, 'a', 'A'], [2, 'b', 'B'], [3, 'c', 'C'], [4, 'd', 'D']]
```

# web

## 文本复制

```js
// 浏览器的安全控制，需要用户主动触发，否则会报错
const copy = (text) => navigator.clipboard?.writeText && navigator.clipboard.writeText(text)
copy('你需要粘贴的文本')
```

# 日期

```js
new Data().toISOString();
// '2023-06-27T03:52:13.758Z'
```

### 获取某年某月的第一天

```js
const getFirstDate = (d = new Date()) => new Date(d.getFullYear(), d.getMonth(), 1);
```

### 获取某年某月的最后一天

```js
// new Date传入的date为0时，表示上个月的最后一天
const getLastDate = (d = new Date()) => new Date(d.getFullYear(), d.getMonth() + 1, 0);
```

# 函数

## 判断一个函数是否属于异步函数

```js
const isAsyncFunction = (v) => Object.prototype.toString.call(v) === '[object AsyncFunction]'
```

# 其他

## 强制等待一段时间

```js
const sleep = async (t) => new Promise((resolve) => setTimeout(resolve, t));
sleep(2000).then(() => {console.log('time')});
```

