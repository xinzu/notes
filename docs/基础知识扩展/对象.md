第六章  面向对象的程序设计 



### 认识对象

什么是对象  ` 无序属性的集合，其属性可以包含基本值、对象或者函数`  `哈希表`



#### 1. 属性类型

对象在创建时都带有一些特征值 【es5 中使用属性描述了这些特性】【定义行为】

属性分为两种属性，不同的属性拥有不同的特征  `数据属性`，`访问器属性`



`数据属性`： 一般我们直接定义赋值的都是数据属性

数据属性有四个描述其行为的特征：可删除，for-in可遍历，可修改，数据值

默认 ：  [[` Configurable `]] 、 [[` Enumerable` ]] 、  [[ `Writable` ]]   默认为 `true`

​				 [[ `Value` ]] 默认为   `undefined`



要修改默认的特征可以调用 `Object.defineProperty()`这个方法



 在调用`Object.defineProperty()`方法创建一个新的属性时[描述符对象]，如果不指定，`configurable`、`enumerable`、`writable` 特性的默认值都是 false 

```js

//普通的属性 赋值 读取 
var a = {'b':'c'}

a.b = 20;
// 内部属性 赋值读取 
// 有一些内置属性具有指定的特征
// Math.PI  此值就不可以修改

Math.PI = 10 

// 修改特征 

var obj = {};
//  三个参数  属性所在的对象 ，属性的名字 和 一个描述符对象
Object.defineProperty(obj, 'name', {
    writable: false,  // 不能修改值
    value: '张三'
})

console.log(obj.name); // 张三
obj.name = '李四';
console.log(obj.name); // 张三,  writable设为 false 后，值就没法修改了。

var person = {
    name: '李四',
    age: 24
}

delete person.name;
console.log(person); // {age: 24}

Object.defineProperty(person, 'age', {
    configurable: false
})

delete person.age; 
console.log(person);// {age: 24} configurable特性设为 false 后，就没法使用 delete 删除了。

// 注意： ie8 是第一个实现 Object.definePerporty方法的浏览器,但是不成熟，所以不要在ie8 中使用
```



`访问器属性`   :    包含一对 getter  setter 函数 (都`不是必须`的) 。允许用户在赋值或取值都经过预先设定的函数，从而实现内部属性的那一种特殊效果。

同样具有四个特征；

可删除，可遍历，get时调用的函数，set时调用的函数

`默认`  true,true,undefined,undefined

```js
var book = {
    _year : 2004,//_year前面下划线是常用的记号，表示只能通过对象方法访问的属性
    edition : 1
};
// year 就是访问器属性 
Object.defineProperty(book,"year",{ 
    get : function () {
        return this._year;
    },
    set : function (newValue) {

        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }

});

book.year  即调用 get 方法  赋值的时候 就调用 set 方法 
// 我们当前的 vue 就是使用这个方法，来保证 数据双向绑定

```

2.定义多个属性

`Object.defineProperties()` 可以通过描述符一个定义多个属性。

```js
// 接收两个参数  添加属性的对象  包含多个需要添加和修改的属性的对象
Object.defineProperties(book,{
    "year":{ 
        get : function () {
            return this._year;
        },
        set : function (newValue) {

            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
    },
    "name":{
        value:10
    }
});
```



##### 3.读取属性的特性

` getOwnPropertyDescriptor `







### 创建对象



##### 1. Object 

```js
new Object()
```

`缺点`   使用同一个接口创建很多对象，产生大量代码 

##### 2.字面量

```js
var  a= {b:c}
```

`缺点`   使用同一个接口创建很多对象，产生大量代码 



##### 3.工厂模式 

`原理`  发明一种函数 分装特定接口 返回一个对象   （通过函数 生成特定对象）

`优点`  解决代码重复  

`缺点`  无法解决对象识别的问题   (产生的都是原生对象的实例)

```js
function createPerson （name,age）{
  	var o = new Object();  
    o.name = name ; 
    o.age= age;  
    o.sayName = function(){
        alert(this.name);
    }
    
    return o;
}   
//多次调用 返回一个对象   无法识别这个对象是谁创建的

var person1 = createPerson('ss',10);

```

##### 4.构造函数模式

`原理`   构造函数可以用来创建特定类型的对象  

`优点`  特性 可以通过constructor 标识对象类型 

`缺点`   构造函数中包含方法时  每生成一个新的对象 这个对象中就包含一个新的同名的方法（浪费内存） 实际上没有必要在 执行代码前就把 完成相同任务的方法 绑定在特定对象上 

```js
function Person (name,age){
    this.name = name ; 
    this.age= age; 
    this.sayName = function(){
        alert(this.name);
    }
}   

var person1 = new Person('ss',10); 
// 方法没有公用

//与工厂模式不同
1. 没有显示的创建对象
2. 直接将属性和方法赋值给 this 对象
3. 没有return 语句

```

`new` 操作符的运行过程


1. 创建一个新对象

2. 将构造函数的作用域赋给新对象 （因此 this 指向这个对象） 

3. 执行构造函数代码 

4. 返回新对象 

   

简单实现一个` new`

```js
// 调用构造函数 

function create(Con, ...args) {
   //创建对象
  let obj = {};
  // 构造函数的原型 创建的对象进行原型关联  即为 对象的 __proto__  属性 指向原型对象
  // obj.__proto__ = Con.prototype;
  Object.setPrototypeOf(obj, Con.prototype)
  // 运行函数
  let result = Con.apply(obj, args)
  // 返回对象 
  return result instanceof Object ? result : obj
}

```



`constructor(构造函数属性) ` : 用来标识对象类型   

`instanceof`操作符   `instanceof` 并不关心构造函数，它真正关心的是原型链。 

```js
function B(){};
var A = new B();
console.log(A instanceof B);
```

沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。



 `构造函数`只要使用new 操作符 调用的就是构造函数  不使用它调用的时候 就是普通函数 



5.原型模式

`原理`  每个函数都有一个prototype 的属性 ， 此属性是一个指针，指向一个对象（包含特定类型的所有实例共享的属性和方法）  指向的对象 可以说是 实例的原型对象 

`优点`   共享所有原型对象包含的属性和方法 

`缺点`  原型中所有属性都是被很多实例所共享的， 但是基本类型的属性没有问题 但是所有实例同名引用属性的值都会指向一个地方  

```js
//
function Person () {
    Person.prototype.name = "p1";
    Person.prototype.age = 10;
    Person.prototype.sex = "female";
    Person.prototype.sayName =function(){
        console.log(this.name);
    }
}
/*
function Person () {
}

	Person.prototype.name = "p1";
    Person.prototype.age = 10;
    Person.prototype.sex = "female";
    Person.prototype.sayName =function(){
        console.log(this.name);
    }
    
    
------
function Person () {
}
// 重写  没有construtor
	Person.prototype= {
	//construtor：
		name ： "p1",
		age ： 10,
		sex : "female",
		sayName : function(){
        	console.log(this.name);
   	 	}
	}

*/

var per1 =new Person();
var per2 =new Person();
console.log(Person.prototype);

Person.prototype.isPrototyeOf(per1)
Person.prototype.isPrototyeOf(per2)
```



`原型对象`

1. 任何时候只要创建新函数，就会为该函数创建一个`prototype`属性，此属性指向原型对象
2. 所有原型对象自动获得一个`construtor`构造函数属性    其他方式 的这个值有嘛



`isPrototypeOf` 确定对象之间是否存在关系

`getPrototypeOf` 获取对象的_ _proto_ _ 属性的值



`原型链查找` 从对象实例本身开始--原型对象



`同名属性` 不能被覆盖只能被屏蔽    有不能被屏蔽的时候 

`hasOwnProperty` 检测属性在原型中还是当前实例中

`in`只要能访问就返回true

for  in





##### 5.组合使用构造函数和原型模式 

此为最常见方法

`原理`   

1. 使用构造函数 定义实例专有属性
2. 使用原型模式定义方法和共享属性

`缺点` 独立的构造函数和原型  不利于代码的可读性

```js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ['aa', 'bb'];
}

Person.prototype = {
    constructor:Person,
    SayName : function(){
        alert(this.name);
    }
}

var person1 = new Person("zhangsan", 29, "Software Enginner");
var person2 = new Person("lisi", 31, "Doctor");

person1.friends.push('cc');
alert(person1.friends);    //aa, bb, cc
alert(person2.friends);    // aa, bb
alert(person1.friends === person2.friends);    //false
alert(person1.sayName === person2.sayName);  //true


```



##### 6.动态原型模式



`原理`   通过构造函数初始化原型  有点像单例模式

`缺点` 独立的构造函数和原型  不利于代码的可读性



```js
function Person (name, age, sex) {
    
    this.name = name;
    this.age = age;
    this.sex = sex;
    // 
    if(typeof this.sayName != "function"){  
        Person.prototype.sayName = function(){
            console.log(this.name);
        }
        Person.prototype.sayAge = function(){
            console.log(this.age);
        }
    }
}
var per = new Person("la", 19, "man");
```



##### 7. 寄生构造函数模式

在前几种模式不适用的情况下 使用该模式  

在特殊情况下为对象创建构造函数 ？



`原理`   创建一个函数，分装创建对象的代码，返回新对象  长得和工厂模式一模一样



##### 8.  稳妥构造函数 

没有公共属性，安全模式中使用 ，不适用this



##### 9.es6 class

```javascript
//一种定义构造函数及其原型方法的语法糖
class MyClass {
  // class 方法
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
  
  class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// 类是函数
alert(typeof User); // function

// ...或者，更确切地说是构造方法
alert(User === User.prototype.constructor); // true

// User.prototype 中的方法，比如：
alert(User.prototype.sayHi); // alert(this.name);

// 实际上在原型中有两个方法
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
// 测试枚举             
for(var a in u ){console.log(a)}             
```

Es5 实现
```js
// 以纯函数的重写 User 类

// 1. 创建构造器函数
function User(name) {
  this.name = name;
}
// 任何函数原型默认具有构造器属性，
// 所以，我们不需要创建它

// 2. 向原型中添加方法
User.prototype.sayHi = function() {
  alert(this.name);
};

// 使用方法：
let user = new User("John");
user.sayHi();
```

// 访问器属性 es6
```js
class User {

  constructor(name) {
    // 调用 setter
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Name is too short.");
      return;
    }
    this._name = value;
  }

}

let user = new User("John");
alert(user.name); // John
```
//es5
```js
Object.defineProperties(User.prototype, {
  name: {
    get() {
      return this._name
    },
    set(name) {
      // ...
    }
  }
});
             
```

区别



2. 类方法不可枚举   es6 
3. 类默认使用 use strict  在类构造函数中的所有方法自动使用严格模式。 
4. 可以直接写 访问器属性
5. 





### 对象继承



##### 1. 理解原型链 



1. 所有引用类型（函数、对象、数组），都存在对象特性，即可以自由拓展属性。**（除了null以外）** 

2. 所有的引用类型（函数、对象、数组），都有一个`__proto__`(我们这里称他为*隐形原型*)属性，属性值是一个普通的对象。
3. 所有**函数**都有一个prototype属性，属性值也是一个普通的函数
4. 所有的引用类型（函数、对象、数组），_*proto_*属性值指向它的**构造函数的 prototype**(显性属性)属性值。*
5. *当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_*proto_*（即他的构造函数的prototype）中寻找。如果没有，则会接着往上找，一直上溯到Object.prototype，也就是说所有对象都继承Object.prototype的属性，Object.prototype的原型是null，null没有任何属性和方法。



构造函数、原型和实例的关系

1. 每个构造函数（函数）都有一个原型对象 `prototype`
2. 原型对象都包含一个指向构造函数的指针 `construtor`
3. 而实例都包含一个指向原型对象的内部指针`__proto__`    实例的 `__proto__` 指向构造函数的 `prototype`



把一个对象的`__proto__`指向另一个原型对象,而这个原型对象的`__proto__`又会指向另一个原型对象，这些就会形成原型链



特殊的Function

- 函数都是由Function构造出来的，Function作为函数，是由其自身构建出来，故Function的原型指针指向其自身的原型对象。

```js
console.log(Function.__proto__ === Function.prototype); // true
console.log(Function.prototype.constructor === Function);
```



```js
function Person (name,age){
    this.name = name ; 
    this.age= age; 
    this.class = ['en','math'];
    this.sayName = function(){
        alert(this.name);
    }
}   

Person.prototype.like = 'fruit';
```



继承 我们需要继承什么？

继承的最终目的 ：用最少的代码 可以实现继承公有属性和方法的同时，拥有自己的属性和方法



##### 2.原型链继承

`原理` 让新实例的原型等于父类的实例

`优点`  实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）

`缺点`  

1.新实例无法向父类构造函数传参。

2.继承单一。只能继承一个父类

3.所有新实例都会共享父类原型的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）

```js
function Per (name) {
    
    this.name = name;
}

Per.prototype = new Person();

var per = new Per("la");
var per2 = new Per("la");

per2.class.push('ss') // 

per.class //

```

`per.__proto__ --> (Per.prototype = new Person)`
` Per.prototype.__proto__-->Person.prototype`
 `Person.prototype.__proto__ -->Object.prototype`
 ` Object.prototype.__proto__ --> null`

##### 3.借用构造函数继承   伪造对象 或经典继承

`原理`  用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））

`优点`传递参数  

1、只继承了父类构造函数的属性，没有继承父类原型的属性。

2、解决了原型链继承缺点1、2、3。

3、可以继承多个构造函数属性（call多个）。

4、在子实例中可向父实例传参。

`缺点`  

1、只能继承父类构造函数的属性。

2、无法实现构造函数的复用。（每次用每次都要重新调用）

3、每个新实例都有父类构造函数的副本，臃肿。（构造函数缺点 所有属性都绑定在对应的对象上）

```js
function Con(name){
    Person.call(this,"jer",10)// 调用了 父构造函数 可以传参 提高自由度
    // Person2.call(this,"") 多个构造函数  多继承
    this.name = name;
}

var con1 = new Con('rr');

console.log(con1 instanceoof Person)

```



##### 4.组合继承（组合原型链继承和借用构造函数继承）（常用）

`原理`  结合了两种模式的优点，传参和复用

`优点`

1、可以继承父类原型上的属性，可以传参，可复用。

2、每个新实例引入的构造函数属性是私有的。

`缺点`  调用了两次父类构造函数（耗内存），

// 子类的构造函数会代替原型上的那个父类构造函数（没有理解）。

```js
function C(name){
    Person.call(this,name);//构造函数继承属性
}

C.prototype = new Person();//原型继承方法  new的时候调用第二次 

var per1=new C("aa");

per1.name;   // 构造函数属性
per1.age;  // 原型属性

```



##### 5.原型式继承

`原理`   先创建了一个**临时性**的构造函数，然后将传入的对象作为个构造函数的原型，最后返回这个构造函数的实例 ，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理 。 

`优点`类似于复制一个对象，用函数来包装。 

`缺点` 

1、所有实例都会继承原型上的属性（共享问题）。

2、无法实现复用。（新实例属性都是后面添加的）  （不能传参）

```js
function D(obj){
    function F(){}
    F.prototype = obj;
    return new F();
}

var per4 = new Person()
var per5 = D(per4);
console.log(per5.name)


per5 instanceof Person //

//
new 默认原型对象 create 指定原型对象

Object.create()是Object的内置方法，可以创建一个新对象，使用现有的对象来提供新创建的对象__proto__

Object.create ( proto, [ propertiesObject ] ) 

方法内部定义一个新的空对象obj
将obj.__proto__的对象指向传入的参数proto
将传入的对象属性复制到obj并且返回obj


```

##### 6.寄生式继承

`原理`  就是给原型式继承外面套了个壳子。

`优点`  传参

`缺点`  没用到原型，无法复用

```js
function D(obj){
    function F(){}
    F.prototype = obj;
    return new F();
}
var per4 = new Person();

function E(obj，name){
    var sub = D(obj);// 继承原型
    sub.name = name; //在原来的基础上加上私有的东西
    return sub;
}
var per6 = E(per4,'ee');

// 给原型式继承 加个处理函数传参
```



##### 7.寄生组合式继承（最理想）

`原理` 　

寄生：在函数内返回对象然后调用

组合：1、函数的原型等于另一个实例。

​			2、在函数中用apply或者call引入另一个构造函数，可传参　

`优点`  修复了组合继承的问题

`缺点`	过于繁琐，故不如组合继承

```js
// 寄生
function G(obj){
    function F(){};
    F.prototype = obj;
    return new F();
}
// G 是 F实例的另一种表示
var g1 = G(Person.prototype);

//组合
function Sub(){
    Person.call(this);
}
//重点
Sub.prototype = g1;  //继承 实例
g1.constructor = Sub; // 修复 实例
var sub1 = new Sub(); 
//sub1 就继承了继承 函数属性，父类实例，g1 的函数属性 

sub1.age;

```



##### 8.ES6继承 （class）（extends）

`原理`Class之间通过使用extends关键字，这比通过修改原型链实现继承，要方便清晰很多

 新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 

```js
相当于构造函数的另一种写法
class Point{
    constructor(x,y){
        this.x = x;
        this.y = y;
    }
    toString(){
      console.log(this.x);   
    }
}
class Colorpoint extends Point {
    //这个就是默认方法  使用new 生成实例时  会调用这个方法，
    //如果未定义 会自动添加 
    
    constructor(x,y,color){
        
        //子类必须在constructor方法中调用super方法，否则新建实例时会报错
        //这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象。
        super(x,y); //调用父类构造函数(Point.prototype.constructor.call(this,x,y))
        this.color = color
        
        // 隐式返回 this
        // 如果显示返回对象 就是该对象
    }
    toString(){
        //通过 super调用父类的方法
        return this.color + ' ' + super.toString(); 
    }
}

class A extends B{}
A.__proto__ === B;  //继承属性
A.prototype.__proto__ == B.prototype;//继承方法

typeOf(Colorpoint)
//类的数据类型就是函数，类本身就指向构造函数。
//类的所有方法都定义在类的prototype属性上面。
Colorpoint.prototype.constructor === Colorpoint // true

Object.assign(Colorpoint.prototype, {
  toString(){},
  toValue(){}
});

与 es5 不同之处

1. toString方法是Colorpoint类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。
2. 必须使用new 调用
3.不存在变量提升，必须先声明在使用

与es5 相同之处
1.prototype对象的constructor属性，直接指向“类”的本身
2. 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
3.类的所有实例共享一个原型对象。

Colorpoint.hasOwnProperty('x') // true
Colorpoint.hasOwnProperty('color') // true
Colorpoint.hasOwnProperty('toString') // false


```

“extends” 语法会设置两个原型：

1. 在构造函数的 `"prototype"` 之间设置原型（为了获取实例方法）
2. 在构造函数之间会设置原型（为了获取静态方法）

```js
//继承对象
class A extends Object   和   class A 区别
继承自对象				       继承自函数
构造函数中需要调用父类构造函数 
```



`super`



1. 作为函数使用  `调用父类构造函数`

2. 作为对象使用 `静态时指向父类本身可以调用父类本身的属性和方法`·`指向父类的原型`

```js
//动态时由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。
class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();//  调用父类函数时 会绑定子类的this
    console.log(super.p()); // 2
  }
}

let b = new B();

class A {
  constructor() {
    this.p = 2;
  }
}

class B extends A {
  get m() {
    return super.p;
  }
}

let b = new B();
b.m // undefined

// 用在静态方法之中，这时super将指向父类，而不是父类的原型对象。
class Parent {
  static myMethod(msg) {
    console.log('static', msg);
  }

  myMethod(msg) {
    console.log('instance', msg);
  }
}

class Child extends Parent {
  static myMethod(msg) {
    super.myMethod(msg);
  }

  myMethod(msg) {
    super.myMethod(msg);
  }
}

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2

//在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。

class A {
  constructor() {
    this.x = 1;
  }
  static print() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  static m() {
    super.print();
  }
}

B.x = 3;
B.m() // 3

```

3. 所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 

```js
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined  A.prototype.x
    console.log(this.x); // 3
  }
}

let b = new B();

```

4.  由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 
5. 直接打印 super会报错 由于浏览器不知道是函数还是对象， 所以必须显式指定是作为函数、还是作为对象使用 
6.  **箭头函数没有** `super` 
7.  `[[HomeObject]]`   super 的特殊特征





参考：

 https://juejin.im/post/5d3551fcf265da1ba4322b20#heading-0 

<https://www.cnblogs.com/Grace-zyy/p/8206002.html>

<https://www.cnblogs.com/loveyaxin/p/11151586.html>

<https://segmentfault.com/a/1190000015642813>

 https://zh.javascript.info/class-inheritance 